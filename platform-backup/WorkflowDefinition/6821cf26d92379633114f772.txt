{
	"appsUsed":[
		
	],
	"createdTime":1747641655963,
	"deleted":false,
	"deploymentState":{
		"deployedAt":1759243580693,
		"deployedBy":-1,
		"deployedDefinitionId":"68dbed3c23e6682b9a51ebfb",
		"status":"DEPLOYED",
		"version":52,
		"workflowVersion":73
	},
	"edges":[
		{
			"fromNodeId":"oOSTj",
			"priority":0,
			"skip":false,
			"toNodeId":"V0YNm",
			"type":"next"
		},
		{
			"fromNodeId":"V0YNm",
			"priority":0,
			"skip":false,
			"toNodeId":"2ypMm",
			"type":"next"
		}
	],
	"grants":{
		"configs":[
			{
				"permissions":[
					"V"
				],
				"principalType":"GLOBAL"
			}
		]
	},
	"id":"6821cf26d92379633114f772",
	"lastModifiedBy":-1,
	"lcName":"text to workflow v2 | update workflow adjacency list",
	"modifiedTime":1759371901420,
	"name":"Text to Workflow v2 | Update Workflow Adjacency List",
	"nodes":[
		{
			"context":{
				"appName":"callables",
				"resourceVersion":344,
				"resourceName":"callables_from_automation"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"ZZPbC-1",
			"id":"oOSTj",
			"index":1,
			"inputs":{
				"result":{
					"type":"object",
					"properties":{
						"output_workflow_json":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Output Workflow Json"
						}
					},
					"additionalProperties":false,
					"required":[],
					"dynamic":true
				},
				"setup":{
					"type":"object",
					"properties":{
						"workflow_json":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Workflow Json"
						},
						"updates":{
							"type":"object",
							"properties":{
								"d":{
									"type":"string",
									"title":"d"
								},
								"deleteNodes":{
									"type":"array",
									"items":{
										"type":"string"
									},
									"title":"Delete Nodes"
								},
								"updatedInsertActions":{
									"type":"array",
									"items":{
										"type":"object",
										"properties":{},
										"additionalProperties":false
									},
									"title":"Updated Insert Actions"
								}
							},
							"additionalProperties":false,
							"title":"Updates",
							"required":[
								"d"
							]
						},
						"caseId":{
							"type":"string",
							"title":"Case Id"
						}
					},
					"additionalProperties":false,
					"required":[]
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Trigger via automation",
			"trigger":{
				"type":"CALLABLE"
			},
			"type":"START"
		},
		{
			"additional":{
				"visibleOptionalFields":[
					"root.parameters.updates.deleteNodes.items",
					"root.parameters.updates.updatedInsertActions.items"
				]
			},
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":323,
				"resourceName":"code_by_unifyapps_python",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"ZZPbC-1",
			"id":"V0YNm",
			"index":2,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"updatedWorkflow":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"updatedWorkflow"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"configurationMode":"DEFAULT",
				"input":{
					"type":"object",
					"properties":{
						"workflow_json":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"workflow_json"
						},
						"updates":{
							"type":"object",
							"properties":{
								"deleteNodes":{
									"type":"array",
									"items":{
										"type":"string"
									},
									"title":"deleteNodes"
								},
								"d":{
									"type":"string",
									"title":"d"
								},
								"updatedInsertActions":{
									"type":"array",
									"items":{
										"type":"object",
										"properties":{},
										"additionalProperties":false
									},
									"title":"updatedInsertActions"
								}
							},
							"additionalProperties":false,
							"title":"updates",
							"required":[
								"d"
							]
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"code":"# TODO(LLD): Make this modular, extensible, easy to update, etc.\n\n# ** Dev Note **: Leaf edges for if_else and branches are handled differently.\n# For if_else, the \"next\" from leaves are added in this snippet itself.\n# For branches, the \"next\" from leaves are added in the adj list to graph snippet.\n\nfrom copy import deepcopy\nimport uuid\nfrom typing import Any, Dict, List\n\n\ndef update_workflow(workflow_json: Dict[str, Any],\n                    insert_list: List[Dict[str, Any]] | None = None,\n                    delete_list: List[str] | None = None) -> Dict[str, Any]:\n    \"\"\"\n    Merge inserts / deletes into `workflow_json` following all the rules.\n    \"\"\"\n\n    # ------------------------------------------------------------------ helpers\n    from copy import deepcopy\n    import uuid\n    from typing import Any, Dict, List\n    loopActions = [\n        \"loop_while\",\n        \"loop_for_each\",\n        \"pdf_by_unifyapps_for_each_split_file\",\n        \"pdf_by_unifyapps_for_each_page\",\n    ]\n\n    def _gen_random_id() -> str:\n        import uuid\n        \"\"\"first 5 chars of a random uuid – good enough for local ids\"\"\"\n        return \"n_\" + uuid.uuid4().hex[:5]\n\n    def _add_edge(node: Dict[str, Any], target: str, edge_type: str) -> None:\n        \"\"\"add an edge only if it does not already exist\"\"\"\n        if node[\"node_id\"] == target:\n            return\n        for e in node.setdefault(\"next\", []):\n            if e[\"node_id\"] == target and e[\"edge_type\"] == edge_type:\n                return\n        node[\"next\"].append({\"node_id\": target, \"edge_type\": edge_type})\n\n    def _category(action: str) -> str:\n        if action == \"if_else_condition\":\n            return \"if_else\"\n        if action == \"branch\":\n            return \"branch\"\n        if action in loopActions:\n            return \"loop\"\n        return \"normal\"\n\n    def _transfer_out_edge_type(action: str) -> str:\n        return {\n            \"if_else\":  \"next_after_condition_end\",\n            \"branch\":   \"next_after_branch_end\",\n            \"loop\":     \"next_after_loop_end\",\n            \"normal\":   \"next\",\n        }[_category(action)]\n\n    def _transform_edge_to_child(parent_edge: str, new_action: str) -> str:\n        \"\"\"\n        Rule-1: edge that is moved further down the chain.\n        For a newly-inserted special connector choose the ‘*_after_...’ edge,\n        otherwise default to simple 'next'.\n        \"\"\"\n        cat = _category(new_action)\n        if cat == \"if_else\":\n            return \"next_after_condition_end\"\n        if cat == \"branch\":\n            return \"next_after_branch_end\"\n        if cat == \"loop\":\n            return \"next_after_loop_end\"\n        return \"next\"\n\n\n    # TODO: This logic is not exhaustive (eg. when branch end contains another if_else or loop). Will fix this only if necessary.\n    def _find_last_nodes(id2node: dict, start_id: str) -> set:\n        \"\"\"\n        Return all leaf nodes reachable from `start_id` (following every edge).\n        Very small DFS – cycles are broken with a visited set.\n        \"\"\"\n        stack, visited, leaves = [start_id], set(), set()\n        while stack:\n            nid = stack.pop()\n            if nid in visited or nid not in id2node:\n                continue\n            visited.add(nid)\n            nxt = id2node[nid].get(\"next\", [])\n            if not nxt:\n                leaves.add(nid)\n            else:\n                for e in nxt:\n                    stack.append(e[\"node_id\"])\n        return leaves\n\n\n    def update_group_ids(id2node: Dict[str, Any], trigger_ids: List[str]) -> None:\n        \"\"\"Mutates id2node in-place:\n        1) init all non-triggers to groupId=None, triggers to \"<tid>-1\"\n        2) dfs and assign each node the groupId coming from the\n            parent with the fewest '@'.\"\"\"\n\n        # build adjacency\n        adjacency = {nid: node.get(\"next\", []) for nid, node in id2node.items()}\n\n        # 1) initialize\n        for nid, node in id2node.items():\n            if nid in trigger_ids:\n                node[\"groupId\"] = f\"{nid}-1\"\n            else:\n                node[\"groupId\"] = None\n\n        # helper to compute a child’s groupId from its parent\n        def _calculate_group_id(parent_id: str,\n                                parent_gid: str,\n                                parent_action: str,\n                                edge_type: str) -> str:\n\n            # ------------- Loop parent --------------------------------- #\n            if parent_action in loopActions:\n                if edge_type == \"next_inside_loop\":\n                    return f\"{parent_id}@{parent_gid}@l\"\n                return parent_gid\n\n            # ---------- If-Else parent ----------------------------------------- #\n            if parent_action == \"if_else_condition\":\n                if edge_type == \"next_if_condition_match\":\n                    return f\"{parent_id}@{parent_gid}@y\"\n                if edge_type == \"next_if_not_condition_match\":\n                    return f\"{parent_id}@{parent_gid}@n\"\n                return parent_gid\n\n            # ---------- Branch parent ----------------------------------------- #\n            if parent_action == \"branch\":\n                if edge_type == \"next_in_default_branch\":\n                    return f\"{parent_id}@{parent_gid}@default\"\n                if edge_type.startswith(\"next_in_branch_number\"):\n                    num = edge_type[len(\"next_in_branch_number\"):]\n                    return f\"{parent_id}@{parent_gid}@{num}\"\n                if edge_type.startswith(\"next_in_branch\") and edge_type[len(\"next_in_branch\"):].isdigit():\n                    num = edge_type[len(\"next_in_branch\"):]\n                    return f\"{parent_id}@{parent_gid}@{num}\"\n                return parent_gid\n\n            return parent_gid\n\n        # utility to count nesting = number of '@' in a gid (None→∞)\n        def _nesting_level(gid: str | None) -> int:\n            if gid is None:\n                return float('inf')\n            return gid.count('@')\n\n        # 2) dfs, but only recurse when you improve a child's gid\n        def dfs(cur_id: str) -> None:\n            parent = id2node[cur_id]\n            parent_gid = parent.get(\"groupId\", \"\") or \"\"\n            parent_act = parent.get(\"action_name\", \"\")\n\n            for edge in adjacency.get(cur_id, []):\n                et = edge.get(\"edge_type\", \"\")\n                if \"loopback\" in et:\n                    continue\n\n                child_id = edge.get(\"node_id\")\n                if child_id not in id2node:\n                    continue\n\n                # compute the candidate gid\n                cand_gid = _calculate_group_id(cur_id, parent_gid, parent_act, et)\n                existing_gid = id2node[child_id].get(\"groupId\")\n\n                # if it's better (fewer '@') then adopt and recurse\n                if _nesting_level(cand_gid) < _nesting_level(existing_gid):\n                    id2node[child_id][\"groupId\"] = cand_gid\n                    dfs(child_id)\n\n        # run from every trigger\n        for tid in trigger_ids:\n            dfs(tid)\n\n    def _compact_branch_numbers(id2node: Dict[str, Any]) -> None:\n        \"\"\"\n        After nodes have been deleted, make sure each `branch` root:\n        • no longer references a fully-deleted branch arm\n        • has its remaining numeric arms renumbered contiguously (1 ... N)\n        • keeps the default arm and next_after_branch_end edge unchanged\n        • shows the correct labels in the UI\n        This helper mutates `id2node` in-place and relies on `_add_edge`\n        already being defined in the same file.\n        \"\"\"\n        # ---------- iterate over every branch root --------------------------------\n        for branch in [n for n in id2node.values()\n                    if n.get(\"action_name\") == \"branch\"]:\n\n            root_id        = branch[\"node_id\"]\n            existing_edges = branch.get(\"next\", [])\n\n            # -------- 1. separate numeric / default edges -------------------------\n            numeric_edges: list[Dict[str, Any]] = []\n            default_edge:  Dict[str, Any] | None = None\n\n            for e in existing_edges:\n                et = e[\"edge_type\"]\n\n                if et == \"next_in_default_branch\":\n                    default_edge = e\n                    continue\n\n                # accept “next_in_branch” or  “next_in_branch_number”\n                if et.startswith(\"next_in_branch_number\"):\n                    suffix = et[len(\"next_in_branch_number\"):]\n                elif et.startswith(\"next_in_branch\"):\n                    suffix = et[len(\"next_in_branch\"):]\n                else:\n                    continue\n\n                # keep only edges whose suffix is an int *and* whose wrapper node\n                # still exists *and* still has children (otherwise the whole arm\n                # was deleted).\n                if suffix.isdigit():\n                    wrapper_id = e[\"node_id\"]\n                    if wrapper_id in id2node and id2node[wrapper_id].get(\"next\"):\n                        e[\"_old_idx\"] = int(suffix)\n                        numeric_edges.append(e)\n\n            # skip if no branches left\n            if not numeric_edges:\n                continue\n\n            # sort by their old numeric index\n            numeric_edges.sort(key=lambda e: e[\"_old_idx\"])\n\n            # -------- 2. wipe outgoing edges / inputs; rebuild from scratch -------\n            branch[\"next\"]    = []\n            branch_inputs     = []\n            wrapper_id_map    : Dict[str, str] = {}  # map id old to new\n\n            for new_idx, e in enumerate(numeric_edges, start=1):\n                old_idx   = e[\"_old_idx\"]\n                old_wr_id = e[\"node_id\"]\n                new_wr_id = f\"{root_id}@{new_idx}\"\n\n                # ---- rename wrapper node if index changed -----------------------\n                if new_idx != old_idx:\n                    wrapper_node         = id2node.pop(old_wr_id)\n                    wrapper_node[\"node_id\"] = new_wr_id\n                    wrapper_node.setdefault(\"inputs\", {})[\"name\"] = f\"Branch {new_idx}\"\n                    # protect against collisions (very rare)\n                    id2node.pop(new_wr_id, None)\n                    id2node[new_wr_id]   = wrapper_node\n                    wrapper_id_map[old_wr_id] = new_wr_id\n                else:\n                    # keep the existing label but make sure it's correct\n                    id2node[old_wr_id].setdefault(\"inputs\", {})[\"name\"] = f\"Branch {new_idx}\"\n\n                # ---- recreate edge with new numbering ---------------------------\n                _add_edge(branch, new_wr_id, f\"next_in_branch{new_idx}\")\n\n                branch_inputs.append({\n                    \"id\": str(new_idx),\n                    \"inputs\": {\"name\": f\"Branch {new_idx}\"}\n                })\n\n            # keep default arm exactly as it was\n            if default_edge:\n                _add_edge(branch, default_edge[\"node_id\"], \"next_in_default_branch\")\n                branch_inputs.append({\"id\": \"default\"})\n\n            branch[\"inputs\"] = {\"branches\": branch_inputs}\n\n            # -------- 3. patch every other edge in the graph that still points\n            #            to an old wrapper id -------------------------------------\n            if wrapper_id_map:\n                for node in id2node.values():\n                    for ed in node.get(\"next\", []):\n                        ed_id = ed[\"node_id\"]\n                        if ed_id in wrapper_id_map:\n                            ed[\"node_id\"] = wrapper_id_map[ed_id]\n\n            # -------- 4. finally remove any parentless wrapper nodes ---------------\n            live_wrapper_ids = {ed[\"node_id\"] for ed in branch[\"next\"]}\n            for nid in list(id2node.keys()):\n                if nid.startswith(f\"{root_id}@\") and nid not in live_wrapper_ids and nid != root_id:\n                    del id2node[nid]\n\n\n    # ───────── helper to locate a node’s direct parents ──────────\n    def _direct_parents(id2node: Dict[str, Any], child_id: str) -> List[str]:\n        return [\n            pid for pid, p in id2node.items()\n            if any(e[\"node_id\"] == child_id for e in p.get(\"next\", []))\n        ]\n\n    # leaf that ends a branch arm when that branch has its own\n    # next_after_branch_end target → we must *not* add a loopback here\n    # True iff `leaf_id` belongs to ANY branch arm (numeric or default).\n    _bal_cache: dict[str, bool] = {}\n    _current_loop_root_id: str | None = None\n\n    def _is_branch_arm_leaf(id2node: Dict[str, Any], leaf_id: str) -> bool:\n        if leaf_id in _bal_cache:\n            return _bal_cache[leaf_id]\n\n        stack = [leaf_id]\n        visited: set[str] = set()\n        while stack:\n            cid = stack.pop()\n            for pid in _direct_parents(id2node, cid):\n                if pid in visited:\n                    continue\n                visited.add(pid)\n                parent = id2node[pid]\n\n                if parent.get(\"action_name\") == \"branch\":  # ← hit root\n                    # Skip only if the branch root itself is *inside* the same\n                    # loop body we’re currently processing.\n                    if _current_loop_root_id and _is_descendant_of(parent[\"node_id\"], _current_loop_root_id):\n                        _bal_cache[leaf_id] = True\n                        return True\n                stack.append(pid)\n\n        _bal_cache[leaf_id] = False\n        return False\n\n\n        # True iff `leaf_id` sits in the chain that starts at a\n    #  next_after_branch_end edge coming out of a branch root.\n    _abal_cache: dict[str, bool] = {}\n\n    def _is_after_branch_end_leaf(id2node: Dict[str, Any], leaf_id: str) -> bool:\n        if leaf_id in _abal_cache:\n            return _abal_cache[leaf_id]\n\n        visited: set[str] = set()\n        stack: list[str] = [leaf_id]\n        while stack:\n            cid = stack.pop()\n            for pid in _direct_parents(id2node, cid):\n                if pid in visited:\n                    continue\n                visited.add(pid)\n                # what edge connects pid → cid ?\n                for ed in id2node[pid].get(\"next\", []):\n                    if ed[\"node_id\"] == cid:\n                        if ed[\"edge_type\"] == \"next_after_branch_end\":\n                            _abal_cache[leaf_id] = True\n                            return True\n                stack.append(pid)\n\n        _abal_cache[leaf_id] = False\n        return False\n\n    def _remove_edge(node: Dict[str, Any], target: str, edge_type: str) -> None:\n        \"\"\"delete *all* edges of a given type toward target (if present)\"\"\"\n        node[\"next\"] = [\n            e for e in node.get(\"next\", [])\n            if not (e[\"node_id\"] == target and e[\"edge_type\"] == edge_type)\n        ]\n\n    # ───────── is node `child_id` somewhere under the loop root? ─────────\n    def _is_descendant_of(child_id: str, ancestor_id: str) -> bool:\n        stack, seen = [child_id], set()\n        while stack:\n            nid = stack.pop()\n            if nid == ancestor_id:\n                return True\n            if nid in seen:\n                continue\n            seen.add(nid)\n            stack.extend(_direct_parents(id2node, nid))\n        return False\n\n\n    # ------------------------------------------------------------ Main Code\n    insert_list = insert_list or []\n    delete_list = delete_list or []\n\n    # deep-copy original so we do not mutate caller data\n    id2node = {n[\"node_id\"]: deepcopy(n) for n in workflow_json.get(\"nodes\", [])}\n    original_order = [n[\"node_id\"] for n in workflow_json.get(\"nodes\", [])]\n    insertion_order: list[str] = []\n\n    # ------------------------------------------------------------- Fix trigger node references\n    # 0. Handling of LLM errors: Fix trigger node reference if it exists (if LLM made a mistake)\n\n    # Find trigger\n    trigger_node_id = ''\n    for n_id, node in id2node.items():\n        if 'triggerNode' in node:\n            trigger_node_id = n_id\n            if node[\"node_name\"] == \"triggerToUpdate\":\n                node[\"node_name\"] = \"callables\"\n                node[\"action_name\"] = \"callables_from_automation\"\n\n    # Never delete the trigger node\n    for i, n_id in enumerate(delete_list):\n        if n_id == trigger_node_id:\n            delete_list.pop(i)\n            break\n\n    # Handle invalid insertion of trigger nodes\n    incorrect_trigger_idx = -1\n    for i, op in enumerate(insert_list):\n        if op.get(\"resource_type\") == \"TRIGGER\":\n            incorrect_trigger_idx = i\n            # break --> break was removed to handle the case when LLM mistakenly gives multiple triggers in \"insert\"\n\n    insert_list = insert_list[max(incorrect_trigger_idx, 0):]\n\n    # Now fix parent references to incorrect_trigger_id\n    if incorrect_trigger_idx >= 0:\n        for op in insert_list:\n            if op.get(\"parent_id\") == insert_list[incorrect_trigger_idx-incorrect_trigger_idx]['node_id']:\n                # Special case: LLM doesn't give trigger id\n                # To fix, I find the trigger node from previous workflow and then set that\n                op['parent_id'] = trigger_node_id\n\n        insert_list.pop(incorrect_trigger_idx-incorrect_trigger_idx)\n\n    # ------------------------------------------------------------- INSERTION\n    # 1. first create deterministic mapping for all “#x” ids\n    pseudo2real = {item[\"node_id\"]: _gen_random_id() for item in insert_list}\n\n    # 2. process inserts sequentially\n    for ins in insert_list:\n        new_id = pseudo2real[ins[\"node_id\"]]\n        parent_id = pseudo2real.get(ins[\"parent_id\"], ins[\"parent_id\"])\n        if parent_id not in id2node:\n            continue\n        parent = id2node[parent_id]\n        edge_type_parent_to_new = ins.get(\"edge_type\", \"next\")\n\n        # --- detach any existing child(ren) on the same edge\n        detached_children = []\n        new_parent_next = []\n        for e in parent.get(\"next\", []):\n            if e[\"edge_type\"] == edge_type_parent_to_new:\n                detached_children.append(e[\"node_id\"])\n            else:\n                new_parent_next.append(e)\n        parent[\"next\"] = new_parent_next\n\n        # --- create the new node object\n        new_node = {\n            \"node_id\": new_id,\n            \"node_name\": ins.get(\"node_name\") or ins.get(\"app_name\"),\n            \"action_name\": ins[\"action_name\"],\n            \"next\": []\n        }\n        id2node[new_id] = new_node\n        insertion_order.append(new_id)\n\n        # --- hook parent → new_node\n        _add_edge(parent, new_id, edge_type_parent_to_new)\n\n        # --- hook new_node → previous child(ren) (Rule-1)\n        for old_child in detached_children:\n            new_edge_type = _transform_edge_to_child(edge_type_parent_to_new,\n                                                     new_node[\"action_name\"])\n            _add_edge(new_node, old_child, new_edge_type)\n\n    # ---------------------------------------------------- BRANCH HANDLING\n    for branch in [n for n in id2node.values() if n.get(\"action_name\") == \"branch\"]:\n        root_id = branch[\"node_id\"]\n\n        # Force canonical metadata\n        branch[\"node_name\"] = \"branch\"\n        branch[\"context\"] = {\"appName\": \"branch\", \"type\": \"APPLICATION\"}\n\n        # split edges into arms (+ optional after-branch) ------------------\n        arms: list[tuple[str, str]] = []          # (edge_type, first_node_id)\n        after_branch_end: str | None = None\n        for e in branch.get(\"next\", []):\n            if e[\"edge_type\"] == \"next_after_branch_end\":\n                after_branch_end = e[\"node_id\"]\n            else:\n                arms.append((e[\"edge_type\"], e[\"node_id\"]))\n\n        # wipe current edges; we’ll rebuild them in canonical order\n        branch[\"next\"] = []\n        branch_inputs: list[Dict[str, Any]] = []\n        numbered_counter = 0\n\n        for etype, first_id in arms:\n            # ---------- identify branch ID --------------------------------\n            if etype in (\"next\"):\n                numbered_counter += 1\n                branch_id = str(numbered_counter)\n            elif etype.startswith(\"next_in_branch_number\"):\n                branch_id = etype[len(\"next_in_branch_number\"):]\n            elif etype.startswith(\"next_in_branch\"):\n                branch_id = etype[len(\"next_in_branch\"):]\n            elif etype == \"next_in_default_branch\":\n                branch_id = \"default\"\n            else:\n                numbered_counter += 1\n                branch_id = str(numbered_counter)\n\n            # ---------- DEFAULT arm --------------------------------------\n            if branch_id == \"default\":\n                _add_edge(branch, first_id, \"next_in_default_branch\")\n                branch_inputs.append({\"id\": \"default\"})\n                continue\n\n            # ---------- NUMERIC arm --------------------------------------\n            bc_id = f\"{root_id}@{branch_id}\"\n            first_node = id2node[first_id]\n\n            if first_node.get(\"action_name\") == \"branch_condition\":\n                old_id = first_node[\"node_id\"]\n                if old_id != bc_id:\n                    id2node[bc_id] = first_node\n                    del id2node[old_id]\n                    first_node[\"node_id\"] = bc_id\n                    for n in id2node.values():\n                        for ed in n.get(\"next\", []):\n                            if ed[\"node_id\"] == old_id:\n                                ed[\"node_id\"] = bc_id\n\n                bc_node = first_node\n                bc_node[\"node_name\"] = \"branch_condition\"\n                bc_node[\"action_name\"] = \"branch_condition\"\n                bc_node[\"context\"] = {\n                    \"appName\": \"branch_condition\",\n                    \"resourceName\": \"branch_condition\",\n                    \"resourceVersion\": 0,\n                    \"type\": \"APPLICATION\"\n                }\n                bc_node[\"inputs\"] = {\"name\": f\"Branch {branch_id}\"}\n            else:\n                # create a fresh branch-condition wrapper ------------------\n                bc_node = {\n                    \"node_id\": bc_id,\n                    \"node_name\": \"branch\",\n                    \"action_name\": \"branch\",\n                    \"context\": {\n                        \"appName\": \"branch\",\n                        \"resourceVersion\": 0,\n                        \"type\": \"APPLICATION\"\n                    },\n                    \"inputs\": {\"name\": f\"Branch {branch_id}\"},\n                    \"next\": []\n                }\n                id2node[bc_id] = bc_node\n                insertion_order.append(bc_id)\n                _add_edge(bc_node, first_id, \"next\")   # wrapper → first real node\n\n            # sanitise any legacy edges coming out of bc_node --------------\n            for ed in bc_node.get(\"next\", []):\n                if ed[\"edge_type\"].startswith(\"next_in_branch\"):\n                    ed[\"edge_type\"] = \"next\"\n\n            # hook root ➜ bc_node with canonical edge ----------------------\n            _add_edge(branch, bc_id, f\"next_in_branch{branch_id}\")\n\n            branch_inputs.append({\n                \"id\": branch_id,\n                \"inputs\": {\"name\": f\"Branch {branch_id}\"}\n            })\n\n        # always include a default entry in the inputs list\n        if not any(bi[\"id\"] == \"default\" for bi in branch_inputs):\n            branch_inputs.append({\"id\": \"default\"})\n        branch[\"inputs\"] = {\"branches\": branch_inputs}\n\n        # restore the single next_after_branch_end edge (if any)\n        if after_branch_end and branch.get(\"node_name\").lower() == \"branch\":\n            _add_edge(branch, after_branch_end, \"next_after_branch_end\")\n        elif after_branch_end:\n            _add_edge(branch, after_branch_end, \"next\")\n\n    # -------------------------------------------------- extra post-handling\n    # 1)  if-else : connect every branch-leaf  ──next──► outside-node --> This one is moved to the end so that group ids aren't messed with\n    # 2)  loop    : connect every inside-loop leaf ──loopback_to_loop_start──► loop-node\n    for node in list(id2node.values()):\n\n        # ---------- LOOPS ----------------------------------------------------\n        if node.get(\"action_name\") in loopActions:\n            loop_id = node[\"node_id\"]\n            _current_loop_root_id = loop_id\n            # Step-0: fast lookup of branch roots inside this loop body\n            branch_roots_in_loop = {\n                nid for nid, nd in id2node.items()\n                if nd.get(\"action_name\") == \"branch\"\n                and _is_descendant_of(nid, loop_id)\n            }\n\n            # Step-1: gather all leaves inside the loop body\n            inside_edges = [\n                e for e in node.get(\"next\", [])\n                if e[\"edge_type\"] == \"next_inside_loop\"\n            ]\n            candidate_leaves: set[str] = set()\n            for e in inside_edges:\n                candidate_leaves |= _find_last_nodes(id2node, e[\"node_id\"])\n\n            # Step-2: work out which leaves should get a loopback\n            allowed_loopback: set[str] = set()\n            for leaf in candidate_leaves:     # skip only when branch has after-edge\n                allowed_loopback.add(leaf)\n\n            # Step-3a: remove stale loopbacks\n            for leaf_id in candidate_leaves:\n                _remove_edge(id2node[leaf_id], loop_id, \"loopback_to_loop_start\")\n\n            # Step-3b: ensure exactly one loopback on the allowed leaves\n            for leaf_id in allowed_loopback:\n                _remove_edge(id2node[leaf_id], loop_id, \"loopback_to_loop_start\")\n                _add_edge(id2node[leaf_id], loop_id, \"loopback_to_loop_start\")\n            # ----------------------------------------------------------------\n            # Step-3c: if the loop still has NO `next_inside_loop`, infer it\n            #          from any node that already points back with\n            #          `loopback_to_loop_start`.\n            # ----------------------------------------------------------------\n            if not any(e[\"edge_type\"] == \"next_inside_loop\"\n                       for e in node.get(\"next\", [])):\n                for nid, nd in id2node.items():\n                    for ed in nd.get(\"next\", []):\n                        if ed[\"edge_type\"] == \"loopback_to_loop_start\" and \\\n                           ed[\"node_id\"] == loop_id:\n                            _add_edge(node, nid, \"next_inside_loop\")\n                            break\n                    else:\n                        continue\n                    break\n            # Step-4: branch-root → loop-start “next” when default arm empty\n            for br_id in branch_roots_in_loop:\n                br_node = id2node[br_id]\n                has_after_edge   = any(\n                    e[\"edge_type\"] == \"next_after_branch_end\" for e in br_node.get(\"next\", [])\n                )\n                has_default_arm  = any(\n                    e[\"edge_type\"] == \"next_in_default_branch\" for e in br_node.get(\"next\", [])\n                )\n                if not has_after_edge and not has_default_arm:\n                    _add_edge(br_node, loop_id, \"next\")\n\n            _current_loop_root_id = None\n\n    # ---------------------------------------------------------------- DELETION\n    deletingBranch = False\n    for del_id in delete_list:\n        if id2node[del_id].get(\"action_name\") == \"branch_condition\":\n            deletingBranch = True\n\n    for del_id in delete_list:\n        if del_id not in id2node:\n            continue\n        doomed = id2node[del_id]\n\n        # 1. find every parent pointing to this node\n        parent_ids = [pid for pid, p in id2node.items()\n                      if any(e[\"node_id\"] == del_id for e in p.get(\"next\", []))]\n\n        # 2. which children should be re-attached?\n        child_edge_to_take = _transfer_out_edge_type(doomed[\"action_name\"])\n        children_to_keep = [e[\"node_id\"] for e in doomed.get(\"next\", [])\n                            if e[\"edge_type\"] == child_edge_to_take]\n\n        # --- PATCH: keep loop body when loop root is deleted -----------------\n        if (not children_to_keep) and (doomed.get(\"action_name\") in loopActions):\n            # Re-attach the first node(s) inside the loop\n            children_to_keep = [\n                e[\"node_id\"] for e in doomed.get(\"next\", [])\n                if e[\"edge_type\"] == \"next_inside_loop\"\n            ]\n\n        # 3. remove parent → doomed edge and rewire\n        for pid in parent_ids:\n            parent = id2node[pid]\n            removed_edge_types = [e[\"edge_type\"]\n                                  for e in parent[\"next\"]\n                                  if e[\"node_id\"] == del_id]\n            parent[\"next\"] = [e for e in parent[\"next\"]\n                              if e[\"node_id\"] != del_id]\n\n            # transfer\n            for transferred_child in children_to_keep:\n                for et in removed_edge_types:\n                  # Skip re-attaching conditional-match if it duplicates the after-condition-end\n                    if (parent[\"action_name\"] == \"if_else_condition\"\n                            and et in (\"next_if_condition_match\", \"next_if_not_condition_match\")\n                            and any(o[\"edge_type\"] == \"next_after_condition_end\"\n                                    and o[\"node_id\"] == transferred_child\n                                    for o in parent[\"next\"])):\n                        continue\n                    _add_edge(parent, transferred_child, et)\n\n        if doomed.get(\"action_name\") in loopActions:\n            for node in id2node.values():\n                _remove_edge(node, doomed[\"node_id\"], \"loopback_to_loop_start\")\n\n        # finally eradicate doomed node\n        del id2node[del_id]\n    if deletingBranch:\n        _compact_branch_numbers(id2node)\n\n    # ---------------------------------------------------------------- Prune after first return/stop action\n    stopActions = [\"callables_return_to_automation\", \"callables_return_response_to_api\", \"stop\"]\n    for insertNode in insert_list:\n        if insertNode.get(\"action_name\") in stopActions:\n            realNodeId = pseudo2real[insertNode[\"node_id\"]]\n            if realNodeId in id2node:\n                id2node[realNodeId][\"next\"] = []\n\n    # ---------------------------------------------------------------- Add/Fix return action\n    trigger_action = id2node[trigger_node_id]['action_name']\n    traversal_edges = {\n        'next',\n        'next_after_loop_end',\n        'next_after_condition_end',\n        # 'next_if_condition_match',\n        # 'next_if_not_condition_match',\n        'next_after_branch_end',              # <-- branch-internal edges excluded\n    }\n\n    # dfs to find leaves; assuming if_else can never be leaves as per placeholder logic\n    leaves = set()\n    def _collect_leaves(nid: str):\n        outs = [\n            e for e in id2node[nid].get(\"next\", [])\n            if e[\"edge_type\"] in traversal_edges\n        ]\n        if not outs:\n            leaves.add(nid)\n        for e in outs:\n            _collect_leaves(e[\"node_id\"])\n\n    _collect_leaves(trigger_node_id)\n\n    return_action, return_node_name = (\"stop\", \"stop\")\n    if trigger_action == 'callables_from_automation':\n        return_action, return_node_name = (\"callables_return_to_automation\", \"callables\")\n    elif trigger_action == 'callables_from_api':\n        return_action, return_node_name = (\"callables_return_response_to_api\", \"callables\")\n\n    for leaf_id in list(leaves):\n        leaf = id2node[leaf_id]\n        if (_is_branch_arm_leaf(id2node, leaf_id) or\n            _is_after_branch_end_leaf(id2node, leaf_id)):\n            continue\n        if leaf['action_name'] in stopActions:\n            leaf['action_name'] = return_action\n            leaf['node_name'] = return_node_name\n        else:\n            # append\n            new_node = {\n                'node_id': _gen_random_id(),\n                'action_name': return_action,\n                'node_name': return_node_name,\n                'next': []\n            }\n            id2node[new_node['node_id']] = new_node\n            # Case handling: Assuming if_else and for will have atleast 1 node (placeholder)\n            # regular node: append with \"next\"\n            # if_else: Append with \"next_after_condition_end\" and also handle branch leaves\n            # for: can be leaf --> Append with \"next_after_loop_end\"\n\n            if id2node[leaf_id]['node_name'] == 'loop' or id2node[leaf_id]['node_name']=='pdf_by_unifyapps':\n                _add_edge(id2node[leaf_id], new_node['node_id'], \"next_after_loop_end\")\n            elif id2node[leaf_id]['node_name'] == 'if_else':  # This should never happen now\n                _add_edge(id2node[leaf_id], new_node['node_id'], \"next_after_condition_end\")\n\n                # Find branch leaves and connect to new_node\n                for branch_edge in (\"next_if_condition_match\",\n                                    \"next_if_not_condition_match\"):\n                    for e in [e for e in id2node[leaf_id]['next']\n                              if e[\"edge_type\"] == branch_edge]:\n                        branch_leaves = _find_last_nodes(id2node, e[\"node_id\"])\n                        for _leaf in branch_leaves:\n                            _add_edge(id2node[_leaf], new_node['node_id'], \"next\")\n            elif id2node[leaf_id]['action_name'] == 'branch':\n                _add_edge(id2node[leaf_id], new_node['node_id'], \"next_after_branch_end\")\n            else:\n                _add_edge(id2node[leaf_id], new_node['node_id'], \"next\")\n\n    # ------------------------------------------- clean dangling edge targets\n    valid_ids = set(id2node)\n    for node in id2node.values():\n        node[\"next\"] = [\n            e for e in node.get(\"next\", [])\n            if e[\"node_id\"] in valid_ids\n        ]\n\n    # ------------------------------------------------------------------ PURGE\n    trigger_ids = [\n        n[\"node_id\"] for n in id2node.values()\n        if n.get(\"triggerNode\")\n    ]\n    reachable: set[str] = set()\n\n    def _dfs(nid: str):\n        if nid in reachable or nid not in id2node:\n            return\n        reachable.add(nid)\n        for e in id2node[nid].get(\"next\", []):\n            _dfs(e[\"node_id\"])\n\n    for tid in trigger_ids:\n        _dfs(tid)\n\n    # Calculate group IDs using DFS\n    update_group_ids(id2node, trigger_ids)\n\n    # Post-processing for if_else leaves\n    # Post-processing for if_else leaves\n    for node in list(id2node.values()):\n\n        # ---------- IF / ELSE ------------------------------------------------\n        if node.get(\"action_name\") == \"if_else_condition\":\n            outside_edges = [\n                e for e in node.get(\"next\", [])\n                if e[\"edge_type\"] == \"next_after_condition_end\"\n            ]\n            if outside_edges:\n                outside_id = outside_edges[0][\"node_id\"]\n\n                # connect branch root → condition-end when its arms are the last nodes on this side of the condition.\n                for cond_edge in [ed for ed in node[\"next\"]\n                                  if ed[\"edge_type\"] in (\n                                      \"next_if_condition_match\",\n                                      \"next_if_not_condition_match\")]:\n                    br_root = id2node.get(cond_edge[\"node_id\"])\n                    if not br_root:\n                        continue\n\n                    if br_root.get(\"action_name\") == \"branch_condition\":\n                        if any(ed[\"edge_type\"] == \"next_after_branch_end\"\n                            for ed in br_root.get(\"next\", [])):\n                            continue\n\n                    # if branch root has next successor *inside* the condition body\n                    has_internal_tail = any(\n                        (not ed[\"edge_type\"].startswith(\"next_in_branch\")) and\n                        ed[\"edge_type\"] not in (\n                            \"next_in_default_branch\",\n                            \"next_after_branch_end\")\n                        for ed in br_root.get(\"next\", [])\n                    )\n                    if not has_internal_tail and br_root.get(\"action_name\").lower() == \"branch\":\n                        _add_edge(br_root, outside_id, \"next_after_branch_end\")\n                    elif not has_internal_tail:\n                        _add_edge(br_root, outside_id, \"next\")\n\n                # connect branch-arm leaves when the after-edge remains INSIDE the condition --------------\n                #  branch-root ──next_after_branch_end──► <internal_node>  (still\n                #  inside the if-else).  In that case every arm-leaf must have\n                #  a plain ‘next’ edge to  <internal_node>.\n\n                for cond_edge in (ed for ed in node[\"next\"]\n                                  if ed[\"edge_type\"] in (\n                                      \"next_if_condition_match\",\n                                      \"next_if_not_condition_match\")):\n\n                    br_root = id2node.get(cond_edge[\"node_id\"])\n                    if not br_root:\n                        continue\n\n                    aft_targets = [ed[\"node_id\"] for ed in br_root.get(\"next\", [])\n                                   if ed[\"edge_type\"] == \"next_after_branch_end\"]\n                    if not aft_targets:\n                        continue\n                    aft_id = aft_targets[0]\n\n                    # keep only when that after-edge target is still **inside**\n                    # this condition (i.e. descendant of the condition node)\n                    if not _is_descendant_of(aft_id, node[\"node_id\"]):\n                        continue\n\n                    # add ‘next’ on every real leaf of every arm\n                    for arm_ed in br_root.get(\"next\", []):\n                        if arm_ed[\"edge_type\"].startswith(\"next_in_branch\") or \\\n                           arm_ed[\"edge_type\"] == \"next_in_default_branch\":\n                            for lf in _find_last_nodes(id2node, arm_ed[\"node_id\"]):\n                                if id2node[lf].get(\"action_name\") == \"branch_condition\":\n                                    continue                # wrapper, keep as is\n                                _add_edge(id2node[lf], aft_id, \"next\")\n\n    # -------- Strip successors **only** when the after-edge already jumps\n    #         outside the condition; keep them when it points inside. ----------\n    for _nid, _nd in id2node.items():\n        # Only touch pure leaf nodes: branch-arm leaf, not a wrapper, and NO\n        # existing successors whatsoever.\n        if not (_is_branch_arm_leaf(id2node, _nid) and\n                _nd.get(\"action_name\") != \"branch_condition\" and\n                len(_nd.get(\"next\", [])) == 0):\n            continue\n        # walk up to the enclosing branch root\n        parents = _direct_parents(id2node, _nid)\n        while parents:\n            pid = parents[0]\n            pnode = id2node[pid]\n            if pnode.get(\"action_name\") == \"branch\":\n                # locate the surrounding if-else condition (first ancestor)\n                anc = pid\n                while anc and id2node[anc].get(\"action_name\") != \"if_else_condition\":\n                    pp = _direct_parents(id2node, anc)\n                    anc = pp[0] if pp else None\n                cond_id = anc\n\n                aft_targets = [ed[\"node_id\"] for ed in pnode.get(\"next\", [])\n                               if ed[\"edge_type\"] == \"next_after_branch_end\"]\n                # outside-jump ⇒ wipe successors; inside-jump ⇒ keep\n                if not aft_targets or \\\n                   not _is_descendant_of(aft_targets[0], cond_id):\n                    _nd[\"next\"] = []\n                break\n            parents = _direct_parents(id2node, pid)\n\n    # produce ordered list: original order, then inserted nodes, keep only reachable\n    final_nodes = []\n    for nid in original_order + insertion_order:\n        if nid in reachable:\n            final_nodes.append(id2node[nid])\n    # any leftover reachable nodes not already appended\n    for nid in reachable:\n        if nid not in {n[\"node_id\"] for n in final_nodes}:\n            final_nodes.append(id2node[nid])\n\n    return {\"nodes\": final_nodes}\n\ninsert = updates.get(\"updatedInsertActions\", [])\ndelete = updates.get(\"deleteNodes\", [])\n\n# Update the workflow\nupdated_workflow = update_workflow(workflow_json, insert, delete)\n\n# Print the result\nresult = {\n    'updatedWorkflow': updated_workflow\n}",
				"isAsync":false,
				"python_version":"3.12",
				"parameters":{
					"updates":{
						"updatedInsertActions":{
							"ua:type":"mappedArray",
							"source":"{{ oOSTj.outputs.updates.updatedInsertActions }}",
							"items":"{{ oOSTj.outputs.updates.updatedInsertActions[0] }}"
						},
						"deleteNodes":{
							"ua:type":"mappedArray",
							"source":"{{ oOSTj.outputs.updates.deleteNodes }}",
							"items":"{{ oOSTj.outputs.updates.deleteNodes[0] }}"
						},
						"d":"{{ oOSTj.outputs.updates.d }}"
					},
					"workflow_json":"{{ oOSTj.outputs.workflow_json }}"
				}
			},
			"skip":false,
			"subTitle":"Update workflow adj list",
			"title":"Execute Python script",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":350,
				"resourceName":"callables_return_to_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"ZZPbC-1",
			"id":"2ypMm",
			"index":3,
			"inputs":{
				"result":{
					"output_workflow_json":"{{ V0YNm.outputs.result.updatedWorkflow }}"
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to automation",
			"type":"STOP"
		}
	],
	"ownerUserId":39717,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":true,
	"tags":[
		
	],
	"version":74
}