{
	"appsUsed":[
		
	],
	"createdTime":1759213482808,
	"deleted":false,
	"edges":[
		{
			"fromNodeId":"n_zWwTH",
			"priority":0,
			"skip":false,
			"toNodeId":"n_7doD3",
			"type":"next"
		},
		{
			"fromNodeId":"n_7doD3",
			"priority":0,
			"skip":false,
			"toNodeId":"n_ES15y",
			"type":"next"
		}
	],
	"id":"68db77aacdaf6406f025cbae",
	"lastModifiedBy":44105,
	"lcName":"dp-func-fusionintg-prod-sa",
	"modifiedTime":1759226958333,
	"name":"dp-func-fusionintg-prod-sa",
	"nodes":[
		{
			"context":{
				"appName":"callables",
				"resourceVersion":966,
				"resourceName":"callables_from_api"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_nz9mE-1",
			"id":"n_zWwTH",
			"index":1,
			"inputs":{
				"request":{
					"contentType":"application/json"
				},
				"endpointType":"REST",
				"response":[
					{
						"status":200,
						"contentType":"application/json",
						"textBody":{
							"type":"string"
						},
						"body":{
							"type":"object"
						},
						"namespaces":[]
					}
				],
				"streamingResponse":false
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Trigger via API",
			"trigger":{
				"type":"CALLABLE"
			},
			"type":"START"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":829,
				"resourceName":"code_by_unifyapps_python",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":true,
			"fallbackMode":"STOP",
			"groupId":"_nz9mE-1",
			"id":"n_7doD3",
			"index":2,
			"inputs":{
				"output":{
					"type":"object",
					"additionalProperties":false,
					"required":[],
					"properties":{
						"result":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Result"
						}
					}
				},
				"input":{
					"type":"object",
					"additionalProperties":false,
					"required":[],
					"properties":{
						"reqBody":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Req Body"
						}
					}
				},
				"configurationMode":"MANUAL",
				"code":"import logging\nimport os\nimport requests\nfrom requests import Session\n\nfrom zeep import Settings\nfrom zeep.transports import Transport\nfrom zeep.wsse.username import UsernameToken\n\n# import pyodbc\nimport pandas as pd\n\nfrom urllib3 import disable_warnings\nfrom urllib3.exceptions import InsecureRequestWarning\n\nfrom datetime import datetime\nimport xml.etree.ElementTree as ET\n\n# from libs.extraction_utils.APIM import APIM\n# from libs.extraction_utils.TaskInfo import TaskInfo\n# from libs.fusion_services.Schedule import Schedule\n\n\n\nclass Security:\n    '''\n    This class is used to handle the Oracle BIP Security Service\n    '''\n\n    def __init__(self, apim):\n        self.access_token = None\n        self.subscription_key = apim.internal_subscription_key\n\n        self.status = 'SUCCESS'\n        self.message = None\n\n        fusion_access_token_endpoint = os.getenv(Const.APIMTokenEndpoint)\n\n        headers = {'Ocp-Apim-Subscription-Key': f'{apim.public_subscription_key}',\n                   'Content-Type':'application/x-www-form-urlencoded'}\n                \n        body = f'client_id={apim.client_id}&'\\\n                'grant_type=client_credentials&'\\\n                f'client_secret={apim.client_secret}&'\\\n                f'resource={apim.resource}'\n\n        try:\n            logging.info(\"Log in to Fusion requested\")\n\n            response = requests.post(\n                url=fusion_access_token_endpoint,\n                headers=headers,\n                data=body,\n                verify=False\n            )\n\n            if response.status_code == 200:\n                response_data = response.json()\n                self.access_token = response_data['access_token']\n                logging.info(f\"Log in to Fusion success.\")\n            else:\n                raise Exception(response.text)\n        except Exception as ex:\n            self.status = 'FAILED'\n            self.message = f'Login to Fusion failed. {str(ex)}'\n            logging.info(f\"Log in to Fusion failed. {str(ex)}\")\n\n\n    def get_access_token(self):\n        logging.info(f\"Returning access token\")\n        return self.access_token\n    \n    def get_subscription_key(self):\n        logging.info(f\"Returning subscription key\")\n        return self.subscription_key\n    \n\nclass SoapQuery:\n    def __init__(self, access_token, subscription_key):\n        self.access_token = access_token\n        self.subscription_key = subscription_key\n\n    def set_schedule_report_header(self):\n        return {\n            \"Content-Type\": \"text/xml\",\n            \"Ocp-Apim-Subscription-Key\": f\"{self.subscription_key}\",\n            \"Ocp-Apim-Trace\": \"true\",\n            \"SOAPAction\": \"scheduleReport\",\n            \"Authorization\": f\"Bearer {self.access_token}\"\n        }\n\n    def set_schedule_status_header(self):\n        return {\n            \"Content-Type\": \"text/xml\",\n            \"Ocp-Apim-Subscription-Key\": f\"{self.subscription_key}\",\n            \"Ocp-Apim-Trace\": \"true\",\n            \"SOAPAction\": \"getScheduledReportStatus\",\n            \"Authorization\": f\"Bearer {self.access_token}\"\n        }\n\n    def set_apim_header(self, soap_action):\n        pass\n\n    def set_schedule_status_query(self, scheduled_job_id):\n        return f\"\"\"\n        <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:v2=\"http://xmlns.oracle.com/oxp/service/v2\">\n            <soapenv:Header/>\n            <soapenv:Body>\n                <v2:getScheduledReportStatus>\n                    <v2:scheduledJobID>{scheduled_job_id}</v2:scheduledJobID>\n                    <v2:userID>{os.getenv(Const.FusionEndPointUserName)}</v2:userID>\n                    <v2:password>{os.getenv(Const.FusionEndPointPassword)}</v2:password>\n                </v2:getScheduledReportStatus>\n            </soapenv:Body>\n        </soapenv:Envelope>\n        \"\"\"\n\n    def set_schedule_query(self, parameter_name_values, user_job_name, file_format, report_absolute_path, file_name):\n        return f\"\"\"\n        <soapenv:Envelope xmlns:soapenv=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:v2=\"http://xmlns.oracle.com/oxp/service/v2\">\n            <soapenv:Header/>\n            <soapenv:Body>\n                <v2:scheduleReport>\n                    <v2:scheduleRequest>\n                        <v2:bookBindingOutputOption>?</v2:bookBindingOutputOption>\n                        <v2:compressDeliveryOutputOption>?</v2:compressDeliveryOutputOption>\n                        <v2:dataModelUrl>?</v2:dataModelUrl>\n                        <v2:deliveryChannels>\n                            <v2:ftpOptions>\n                                <v2:item>\n                                    <v2:ftpServerName>{os.getenv(Const.FTPServerName)}</v2:ftpServerName>\n                                    <v2:ftpUserName>{os.getenv(Const.FTPUserName)}</v2:ftpUserName>\n                                    <v2:ftpUserPassword>{os.getenv(Const.FTPPassword)}</v2:ftpUserPassword>\n                                    <v2:remoteFile>{os.getenv(Const.FTPRootFolder) + file_name}</v2:remoteFile>\n                                    <v2:sftpOption>False</v2:sftpOption>\n                                </v2:item>\n                            </v2:ftpOptions>\n                        </v2:deliveryChannels>\n                        <v2:endDate></v2:endDate>\n                        <v2:mergeOutputOption>false</v2:mergeOutputOption>\n                        <v2:notifyHttpWhenFailed>false</v2:notifyHttpWhenFailed>\n                        <v2:notifyHttpWhenSkipped>false</v2:notifyHttpWhenSkipped>\n                        <v2:notifyHttpWhenSuccess>false</v2:notifyHttpWhenSuccess>\n                        <v2:notifyHttpWhenWarning>false</v2:notifyHttpWhenWarning>\n                        <v2:notifyWhenFailed>false</v2:notifyWhenFailed>\n                        <v2:notifyWhenSkipped>false</v2:notifyWhenSkipped>\n                        <v2:notifyWhenSuccess>false</v2:notifyWhenSuccess>\n                        <v2:notifyWhenWarning>false</v2:notifyWhenWarning>\n                        <v2:repeatCount>1</v2:repeatCount>\n                        <v2:repeatInterval>0</v2:repeatInterval>\n                        <v2:reportRequest>\n                            <v2:attributeFormat>{file_format}</v2:attributeFormat>\n                            <v2:attributeLocale>en-US</v2:attributeLocale>\n                            <v2:attributeTemplate>Test_report</v2:attributeTemplate>\n                            <v2:byPassCache>true</v2:byPassCache>\n                            <v2:flattenXML>false</v2:flattenXML>\n                            <v2:parameterNameValues>\n                                <v2:listOfParamNameValues>\n                                    {self._set_parameter_name_values(parameter_name_values)}\n                                </v2:listOfParamNameValues>\n                            </v2:parameterNameValues>\n                            <v2:reportAbsolutePath>{report_absolute_path}</v2:reportAbsolutePath>\n                            <v2:sizeOfDataChunkDownload>-1</v2:sizeOfDataChunkDownload>\n                        </v2:reportRequest>\n                        <v2:saveDataOption>true</v2:saveDataOption>\n                        <v2:saveOutputOption>true</v2:saveOutputOption>\n                        <v2:scheduleBurstingOption>false</v2:scheduleBurstingOption>\n                        <v2:scheduleBurstringOption>false</v2:scheduleBurstringOption>\n                        <v2:scheduleChunkingOption>false</v2:scheduleChunkingOption>\n                        <v2:schedulePublicOption>false</v2:schedulePublicOption>\n                        <v2:startDate></v2:startDate>\n                        <v2:useUTF8Option>false</v2:useUTF8Option>\n                        <v2:userJobName>{user_job_name}</v2:userJobName>\n                    </v2:scheduleRequest>\n                    <v2:userID>{os.getenv(Const.FusionEndPointUserName)}</v2:userID>\n                    <v2:password>{os.getenv(Const.FusionEndPointPassword)}</v2:password>\n                </v2:scheduleReport>\n            </soapenv:Body>\n        </soapenv:Envelope>\n        \"\"\"\n\n    def _set_parameter_name_values(self, param_dict):\n        parameter_string = ''\n        for key, val in param_dict.items():\n            item = f\"\"\"\n                <v2:item>\n                    <v2:multiValuesAllowed>false</v2:multiValuesAllowed>\n                    <v2:name>{key}</v2:name>\n                    <v2:refreshParamOnChange>false</v2:refreshParamOnChange>\n                    <v2:selectAll>false</v2:selectAll>\n                    <v2:templateParam>false</v2:templateParam>\n                    <v2:useNullForAll>false</v2:useNullForAll>\n                    <v2:values>\n                        <v2:item>{val}</v2:item>\n                    </v2:values>\n                </v2:item>\"\"\"\n            parameter_string += item\n        return parameter_string\n\n\nclass DatabaseWriter:\n    '''\n    This calss is used to log/ update the status of the extraction to \n    tables in DPINTG database\n    '''\n\n    def __init__(self):\n        input_conn_str = str(os.getenv(Const.StagingDBConnectionString))\n\n        # Check for correct driver \n        drivers = [item for item in pyodbc.drivers()]\n\n        for driver in drivers:\n            if 'ODBC' in driver and 'SQL Server' in driver:\n                useDriver = driver\n\n        # Replace exisiting driver with correct driver \n        variable_value_pairs = input_conn_str.split(\";\")\n        variables = {}\n\n        for pair in variable_value_pairs:\n            if \"=\" in pair:\n                variable, value = pair.split(\"=\")\n                variables[variable] = value\n\n        variables['Driver'] = '{' + useDriver + '};'\n\n        # Construct the updated connection string\n        self.conn_str = \";\".join([f\"{variable}={value}\" for variable, value in variables.items()])\n        \n        logging.info(f\"Database writer object initialized.\")\n\n    @staticmethod\n    def _populate_database_table(sql_table_name):\n        # Get the connection string for the database\n        conn_str = os.environ.get('StagingDBConnectionString')\n\n        try:\n            sql_query = Const.SQLSelectTopOne + sql_table_name\n\n            # Establish a database connection\n            conn = pyodbc.connect(conn_str)\n\n            # Execute the SQL query and fetch the results into a pandas DataFrame\n            table = pd.read_sql_query(sql_query, conn)\n\n            return table\n\n        except Exception as ex:\n            raise ex\n        \n\n    def function_execution_log(self, bip_id, chunk_number, bip_type, method_name, status, data_size, message):\n        try:\n            param_list = [bip_id, chunk_number, bip_type, method_name, status,\n                          data_size, message]\n            self.execute_procedure_with_parameter(Const.ExecutionLogSPName, param_list)\n\n            logging.info(\"Executed function execution log stored procedure\")\n        except Exception as ex:\n            logging.error(f\"Failed to execute function execution log stored procedure. {str(ex)}\")\n            raise ex\n        \n    def report_execution_log(self, bip_entity_id, bip_report_id, bip_type, bip_status, bip_execution_start_time):\n        try:\n            param_list = [bip_entity_id, bip_report_id, bip_type, bip_status, bip_execution_start_time]\n            self.execute_procedure_with_parameter(Const.ReportExecutionLogInsertSPName, param_list)\n\n            logging.info(\"Executed report execution log insert stored procedure\")\n        except Exception as ex:\n            logging.error(f\"Failed to execute report execution log insert stored procedure. {str(ex)}\")\n            raise ex\n    \n    def report_execution_log_update(self, bip_entity_id, bip_job_id, bip_status, bip_execution_end_time,\n                                exception_message):\n        try:\n            param_list = [bip_entity_id, bip_job_id, bip_status, bip_execution_end_time, exception_message]\n            self.execute_procedure_with_parameter(Const.ReportExecutionLogUpdateSPName, param_list)\n            logging.info(f\"Executed report execution log status update stored procedure\")\n        except Exception as ex:\n            raise ex\n\n    def config_table_status_update(self, bip_id, pkl_extraction_status, extraction_status, extraction_date,\n                                   last_modified_date, ingestion_status):\n        try:\n            param_list = [bip_id, pkl_extraction_status, extraction_status, extraction_date, last_modified_date,\n                          ingestion_status]\n            self.execute_procedure_with_parameter(Const.ConfigurationStatusUpdateSPName, param_list)\n            logging.info(f\"Executed config table status update stored procedure\")\n        except Exception as ex:\n            raise ex\n        \n    def set_extraction_status(self, bip_id, status, message, bip_type):\n        \n        try:\n            param_list = [bip_id, status, message, bip_type, None, None, None, None]\n\n            self.execute_procedure_with_parameter(Const.ErrorLogSPName, param_list)\n\n            logging.info(\"Executed set extraction status stored procedure\")\n        except Exception as ex:\n            raise ex\n        \n    def execute_procedure_with_parameter(self, stored_procedure_name, param_list):\n        try:\n            with pyodbc.connect(self.conn_str) as con:\n                con.timeout = Const.ConnectionTimeout\n                cursor = con.cursor()\n\n                # Assuming the stored procedure exists in the database\n                cursor.execute(f\"EXEC {stored_procedure_name}\",\n                               param_list)  # Adjust the number of placeholders as needed\n        except Exception as ex:\n            raise ex\n\n\nclass Const:\n    \"\"\"\n    Constants used in Fusion extraction function app.\n    \"\"\"\n\n    session = Session()\n    session.verify = False\n\n    wsse= UsernameToken(os.getenv('FUSION_ENDPOINT_USERNAME'), os.getenv('FUSION_ENDPOINT_PASSWORD'))\n\n    # Disable SSL Verification\n    transport = Transport(timeout=1200, session=session)\n    settings = Settings(strict=False)\n\n    # Buffer Constants\n    SizeOfDataChunkDownload = -1\n    TimeoutInMinutes = 20\n    MaxBufferSize = 2147483647\n    MaxBufferPoolSize = 2147483647\n    MaxReceivedMessageSize = 2147483647\n\n    # Environment Constants\n    FusionEndPointReportURL = \"FUSION_ENDPOINT_REPORT_URL\"\n    FusionEndPointScheduleURL = \"FUSION_ENDPOINT_SCHEDULE_URL\"\n    FusionEndPointSecurityURL = \"FUSION_ENDPOINT_SECURITY_URL\"\n    FusionEndPointUserName = \"FUSION_ENDPOINT_USERNAME\"\n    FusionEndPointPassword = \"FUSION_ENDPOINT_PASSWORD\"\n    FusionEndPointTimeOutInMinutes = \"FUSION_ENDPOINT_TIMEOUT_IN_MINUTES\"\n    FusionEndPointChunkSizeInMb = \"FUSION_ENDPOINT_CHUNK_SIZE_IN_MB\"\n    FusionHostName = \"FUSION_HOSTNAME\"\n\n    StagingDBConnectionString = \"STAGING_DB_CONNECTION_STRING\"\n\n    # Datalake Constants\n    DataLakeAccount = 'DATA_LAKE_ACCOUNT'\n    DataLakeAccountKey = \"DATA_LAKE_ACCOUNT_KEY\"\n    DataLakeAccountFileSystem = \"DATA_LAKE_ACCOUNT_FILE_SYSTEM\"\n\n    FTPServerName = \"FTP_SERVER_NAME\"\n    FTPUserName = \"FTP_USER_NAME\"\n    FTPPassword = \"FTP_PASSWORD\"\n    FTPRootFolder = \"FTP_ROOT_FOLDER\"\n\n    # Function Name Constants\n    Starter = \"Starter\"\n    Orchestrator = \"Orchestrator\"\n    A_RunReportXml = \"A_RunReportXml\"\n    A_RunReportCsv = \"A_RunReportCsv\"\n    A_LoadXmlData = \"A_LoadXmlData\"\n    A_LoadCsvData = \"A_LoadCsvData\"\n    A_ExecuteMergeSp = \"A_ExecuteMergeSp\"\n    A_PerformCallback = \"A_PerformCallback\"\n    ExtractBIPFunction = \"ExtractBIPFunction\"\n    ScheduleBIPFunction = \"ScheduleBIPFunction\"\n\n    # String Constants\n    CallbackUrl = \"CallbackUrl\"\n    StrMessage = \"Starting activity {0}\"\n    Post = \"post\"\n    pipeSign = '|'\n    equalSign = '='\n    BipTypePKL = \"PKL\"\n    BipTypeAudit = \"AUDIT\"\n    BipTypeData = \"DATA\"\n    Xml = \"xml\"\n    Csv = \"csv\"\n    Json = \"json\"\n    XmlRootElement = \"DATA_DS\"\n    ReportSchedularPrefix = \"DP_Schedular_\"\n\n    # SQL Constants\n    # SQL Parameters\n    BipId = \"@BipId\"\n    TableName = \"@TableName\"\n    BipType = \"@BipType\"\n    PKLExtractionStatus = \"@PKLExtractionStatus\"\n    ExtactionStatus = \"@ExtactionStatus\"\n    LastExtactionDate = \"@LastExtactionDate\"\n    LastModifiedDate = \"@LastModifiedDate\"\n    MethodName = \"@MethodName\"\n    ChunkNumber = \"@ChunkNumber\"\n    IngestionStatus = \"@IngestionStatus\"\n    FailLogMessage = \"@Message\"\n    Status = \"@Status\"\n    DataSize = \"@DataSize\"\n\n    XmlDocumentHeader = \"<?xml version=\\\"1.0\\\" standalone=\\\"yes\\\"?>\"\n    # SQL Queries\n    SQLSelectTopOne = \"SELECT TOP 1 * FROM \"\n    SQLTruncateTable = \"TRUNCATE TABLE \"\n    PKLTablePrefix = \"stg.PKL_STG_FU_\"\n    TEMPTablePrefix = \"stg.TEMP_STG_FU_\"\n    ConnectionTimeout = 1200\n\n    # SQL SPs\n    # LoadXmlSPName = \"[dbo].[USP_LOAD_FUSION_XML_DATA]\"\n\n    ConfigurationStatusUpdateSPName = \"[config].[USP_UPDATE_FUSION_BIP_REPORT_CONFIGURATION_STATUS] \" \\\n                                      \"@BipId = ? \"\\\n                                      \",@PKLExtractionStatus = ?\"\\\n                                      \",@ExtactionStatus = ?\"\\\n                                      \",@LastExtactionDate = ?\"\\\n                                      \",@LastModifiedDate = ?\"\\\n                                      \",@IngestionStatus = ?\"\n\n    ExecutionLogSPName = \"[audit].[USP_INSERT_FUSION_BIP_REPORT_EXTRACTION_EXECUTION_LOG] \"\\\n                         \"@BipId = ?\" \\\n                         \",@ChunkNumber = ?\" \\\n                         \",@BipType = ?\" \\\n                         \",@MethodName = ? \" \\\n                         \",@Status = ?\" \\\n                         \",@DataSize = ?\" \\\n                         \",@Message = ?\"\n    \n    ReportExecutionLogInsertSPName = \"[audit].[USP_INSERT_FUSION_BIP_REPORT_EXECUTION_LOG] \"\\\n                                     \"@BIP_ENTITY_ID = ?\" \\\n                                     \",@BIP_JOB_ID = ?\" \\\n                                     \",@BIP_TYPE = ?\" \\\n                                     \",@BIP_STATUS = ? \" \\\n                                     \",@BIP_EXECUTION_START_TIME = ?\"\n    \n    ReportExecutionLogUpdateSPName = \"[audit].[USP_UPDATE_FUSION_BIP_REPORT_EXECUTION_LOG] \"\\\n                                     \"@BIP_ENTITY_ID = ?\" \\\n                                     \",@BIP_JOB_ID = ?\" \\\n                                     \",@BIP_STATUS = ? \" \\\n                                     \",@BIP_EXECUTION_END_TIME = ?\" \\\n                                     \",@EXCEPTION_MESSAGE = ?\"\n\n    ErrorLogSPName = \"[config].[USP_SET_FUSION_BIP_REPORT_EXTACTION_STATUS] \"\\\n                        \"@BipId = ?\"\\\n                        \",@Status = ?\"\\\n                        \",@Message = ?\"\\\n                        \",@BipType = ?\"\\\n                        \",@DatalakeStagDeltaCnt = ?\"\\\n                        \",@DatalakeStagParquetCnt = ?\"\\\n                        \",@DatalakeIntgCount = ?\"\\\n                        \",@FusionDataCount = ?\"\n\n    # Status Messages Constants\n    XmlLoadSuccessMessage = \"Xml document successfully loaded into \"\n    LoadRowCount = \" with row count \"\n    XmlLoadFailedMessage = \"Xml document failed to load into \"\n    MergeSuccessMessage = \" stored procedure successfully executed.\"\n    MergeFailedMessage = \" stored procedure execution failed.\"\n    BulkInsertSuccessMessage = \"Csv data successfully insert to \"\n    BulkInsertFailMessage = \"Csv data insert failed to \"\n    ExecutionCompleted = \"Execution Completed\"\n    OK = \"OK\"\n    Error = \"ERROR : \"\n    InProgressStatus = \"IN PROGRESS\"\n    SuccessStatus = \"SUCCESS\"\n    FailedStatus = \"FAILED\"\n    SuccessStatusCode = \"SUCCESS\"\n    ErrorStatusCode = \"ERROR\"\n    InvalidRequestMsg = \"Invalid request! Please check the request format for BIP entity {0}\"\n    RequestAcceptMsg = \"Request Accepted for BIP entity {0}\"\n    FailedToUploadFile = \"Failed to upload file to datalake - \"\n    FailedToRunBipDataChunk = \"Failed to run data BIP chunk - \"\n    FailedToRunBipPkl = \"Failed to run PKL BIP - \"\n\n    # BIP Scheduler Status\n    SchedularInProgressStatus = \"In progress\"\n    SchedularSuccessStatus = \"Success\"\n    SchedularErrorStatus = \"Output has Error\"\n    SchedularFailedStatus = \"Failed\"\n    SchedularDeliveryFailedStatus = \"Delivery failed\"\n    SchedularDeliveryErrorStatus = \"Delivery has Error\"\n    ObjectReferrenceErrorMessage = \"Object reference not set to an instance of an object\"\n\n    # Data lake Constants\n    DataLakeUri = \"https://{0}.dfs.core.windows.net\"\n\n    # APIM Details\n    APIMKVEndpoint = \"APIM_KV_ENDPOINT\"\n    APIMKVCode = \"APIM_KV_CODE\"\n    APIMTokenEndpoint = \"APIM_TOKEN_ENDPOINT\"\n    APIMScheduleEndpoint = \"APIM_SCHEDULE_ENDPOINT\"\n    APIMScheduleStatusEndpoint = \"APIM_STATUS_ENDPOINT\"\n\n\nclass APIM:\n    '''\n    This class is used to handle the Fusion APIM credentials\n    '''\n\n    def __init__(self):\n        self.public_subscription_key =  None\n        self.internal_subscription_key =  None\n        self.client_id = None\n        self.client_secret = None\n        self.resource = None\n\n    def set_public_subscription_key(self, public_subscription_key):\n        self.public_subscription_key = public_subscription_key\n\n    def set_internal_subscription_key(self, internal_subscription_key):\n        self.internal_subscription_key = internal_subscription_key\n\n    def set_client_id(self, client_id):\n        self.client_id = client_id\n\n    def set_client_secret(self, client_secret):\n        self.client_secret = client_secret\n\n    def set_resource(self, resource):\n        self.resource = resource\n\n\nclass TaskInfo:\n    \"\"\"\n    This class is used for maintaining a single configuration state throughout the Function App\n\n    Attributes:\n        BipId (str)         : The BIP ID of the entity.\n        EntityName (str)    : The name of the entity.\n        BipType (str)       : The type of the BIP Report (DATA/ PKL).\n        DataLakePath (str)  : The path to the Raw data zone container associated with the entity.\n        ReportPath (str)    : The path to the BIP report.\n        ParameterList (str) : The list of BIP report parameters.\n        FileName (str)      : The name of the BIP Report.\n        FileFormat (str)    : The format of the BIP report (XML/EXCELS/CSV)\n        ChunkNumber (str)   : The chunk number of the task.\n        CallbackUrl (str)   : The callback URL for the extraction.\n        XmlData (str)       : The XML data for the task.\n        CsvData (str)       : The CSV data for the task.\n        StatusCode (str)    : The status code of the task.\n        Message (str)       : A message associated with the task.\n    \"\"\"\n\n    def __init__(self, bip_id, entity_name, bip_type, data_lake_path, report_path, parameter_list, file_name=None,\n                 file_format='XML', chunk_number=0,\n                 callback_url=None, xml_data=None, csv_data=None, status_code=None, message=None):\n        self.BipId = bip_id\n        self.EntityName = entity_name\n        self.BipType = bip_type\n        self.DataLakePath = data_lake_path\n        self.ReportPath = report_path\n        self.ParameterList = parameter_list\n        self.FileFormat = file_format.upper()\n        self.FileName = file_name\n        self.ChunkNumber = chunk_number\n        self.CallbackUrl = callback_url\n        self.XmlData = xml_data\n        self.CsvData = csv_data\n        self.StatusCode = status_code\n        self.Message = message\n\n        logging.info('Configuration object initialized.')\n\n\nclass Schedule:\n    '''\n    This class is used to handle the Fusion scheduled entities\n    '''\n\n    # Login to fusion and initiate schedule serivce\n    def __init__(self, apim):\n        self.access_token = None\n        self.subscription_key = None\n        self.schedule_job_id = None\n\n        self.message = None\n        self.status = None\n\n        self.fusion_schedule_endpoint = os.getenv(Const.APIMScheduleEndpoint)\n\n        try:\n            sec = Security(apim)\n\n            if sec.status == 'FAILED':\n                raise Exception(sec.message)\n\n            self.access_token = sec.get_access_token()\n            self.subscription_key = sec.get_subscription_key()\n            logging.info(\"Schedule object initialized\")\n        except Exception as ex:\n            self.status = 'FAILED'\n            self.message = f'Failed to connect to schedule service. {str(ex)}'\n            logging.info(\"Failed to initialize Schedule object.\")\n\n\n    # Schdule BIP Report\n    def continue_schedule_bip(self, task_info: TaskInfo):\n        logging.info(\"Continue Schedule BIP\")\n        db_writer = DatabaseWriter()\n\n        try:\n            # Define user job name\n            date_time_str = datetime.utcnow().strftime(\"%Y%m%d_%H%M%S\")\n\n            # Remove unwanted characters (-, :, ,) without using re\n            for ch in \"-:,\":\n                date_time_str = date_time_str.replace(ch, \"\")\n\n            date_time_suffix = date_time_str\n            schedule_job_name = f\"{task_info.EntityName}_{task_info.BipType}_{date_time_suffix}\"\n            user_job_name = Const.ReportSchedularPrefix + \"_\" + schedule_job_name\n\n            # Log function execution to SQL DB\n            db_writer.function_execution_log(task_info.BipId, task_info.ChunkNumber, task_info.BipType, Const.Starter,\n                                             Const.InProgressStatus, 0, None)\n\n            # Schedule the report\n            self.schedule_report(task_info, user_job_name)\n\n            return self.schedule_job_id\n\n        except Exception as ex:\n            task_info.message = str(ex)\n\n            db_writer.set_extraction_status(task_info.BipId, Const.FailedStatus, str(ex), task_info.BipType)\n\n            self.status = 'FAILED'\n            self.message = f\"Scheduling {task_info.BipType} report for {task_info.EntityName} failed! {str(ex)}\"\n\n    # Schdule BIP Report\n    def schedule_report(self, task_info: TaskInfo, user_job_name):\n        logging.info(\"Executing schedule report\")\n        parameter_list = task_info.ParameterList.split('|')\n        parameter_dict = {}\n\n        for i in parameter_list:\n            item_arr = i.split('=')\n            if len(item_arr) > 1:\n                parameter_dict[item_arr[0]] = item_arr[1]\n\n        logging.info(parameter_dict)\n\n        db_writer = DatabaseWriter()\n        db_writer.function_execution_log(task_info.BipId, task_info.ChunkNumber,\n                                         task_info.BipType, Const.A_RunReportXml, Const.InProgressStatus, 0, None)\n\n        try:\n            # Create a report schedule\n            logging.info(\"Scheduled Report\")\n\n            soap_query = SoapQuery(access_token=self.access_token, subscription_key=self.subscription_key)\n\n            file_name = f'{task_info.EntityName}_{task_info.BipType}.{task_info.FileFormat}'\n            logging.info(f\"File Name {file_name}\")\n\n            headers = soap_query.set_schedule_report_header()\n\n            body = soap_query.set_schedule_query(parameter_name_values=parameter_dict,\n                                                    user_job_name=user_job_name,\n                                                    file_format=task_info.FileFormat,\n                                                    report_absolute_path=task_info.ReportPath,\n                                                    file_name=file_name)\n            \n            response = requests.post(self.fusion_schedule_endpoint,\n                                        headers=headers,\n                                        data=body,\n                                        verify=False)\n   \n            logging.info(f\"Response: {response.text}\")\n\n            root = ET.fromstring(response.text)\n\n            # Use XPath to find the specific attribute value\n            self.schedule_job_id = root.find(\".//{http://xmlns.oracle.com/oxp/service/v2}scheduleReportReturn\").text\n            logging.info(f'Schedule Job ID: {self.schedule_job_id}')\n\n            # Update config table status\n            if task_info.BipType in [Const.BipTypePKL, Const.BipTypeAudit, Const.BipTypeData]:\n                db_writer.function_execution_log(task_info.BipId, task_info.ChunkNumber, task_info.BipType, Const.A_RunReportXml,\n                                                 Const.InProgressStatus, 0, None)\n                db_writer.report_execution_log(task_info.BipId, self.schedule_job_id, task_info.BipType, 'Scheduled', datetime.utcnow())\n            else:\n                db_writer.function_execution_log(task_info.BipId, task_info.ChunkNumber, task_info.BipType, Const.A_RunReportXml,\n                                                 Const.SuccessStatus, 0, None)\n        except Exception as ex:\n            logging.info(f\"Schedule Report Failed {str(ex)}\")\n            # Log function execution to SQL DB\n            db_writer.function_execution_log(task_info.BipId, task_info.ChunkNumber, task_info.BipType, Const.A_RunReportXml,\n                                             Const.FailedStatus, 0, str(ex))\n\n            self.status = 'FAILED'\n            self.message = f'Scheduling job failed. {str(ex)}'\n\n            new_exception = Exception(\n                f\"Report Job Name: {user_job_name}, {str(ex)}\")\n\n            raise new_exception\n\n\ndef main(req):\n    '''\n    HTTP Trigger for Schedule Data Ingestion\n    '''\n\n    logging.info('Schedule extraction function received a request.')\n\n    try:\n        req_body = req\n    except ValueError:\n        return {\n            \"status\": 400,\n            \"message\": \"Missing required request parameters.\"\n        }\n    else:\n        task_info = TaskInfo(\n                bip_id = req_body.get('BipId'),\n                chunk_number = req_body.get('ChunkNumber'),\n                entity_name = req_body.get('EntityName'),\n                report_path = req_body.get('ReportPath'),\n                parameter_list = req_body.get('ParameterList'),\n                file_name = None,\n                data_lake_path = req_body.get('DataLakePath'),\n                bip_type = req_body.get('BipType'),\n                file_format = req_body.get('FileFormat'),\n                callback_url=None,\n                xml_data=None,\n                csv_data=None,\n                status_code=None,\n                message=None)\n\n        apim_credentials = req_body.get('APIMCredentials')\n\n        apim = APIM()\n\n        for cred in apim_credentials:\n            if cred['name'] == 'Virtu-Business-Public-sub-key':\n                apim.set_public_subscription_key(cred['value'])\n            elif cred['name'] == 'Virtu-Business-Internal-sub-key':\n                apim.set_internal_subscription_key(cred['value'])\n            elif cred['name'] == 'virtuIntegrationAppClientID':\n                apim.set_client_id(cred['value'])\n            elif cred['name'] == 'virtuIntegrationAppSecret':\n                apim.set_client_secret(cred['value'])\n            elif cred['name'] == 'virtuIntegrationAppAudiance':\n                apim.set_resource(cred['value'])\n                        \n        if task_info.BipId != None:\n            try:\n                scheduler = Schedule(apim)\n\n                if scheduler.status == 'FAILED':\n                    return {\n                            \"status\": 400,\n                            \"message\":  f\"FAILED: {scheduler.message}\"\n                    }\n                else:\n                    schedule_job_id = scheduler.continue_schedule_bip(task_info)\n\n                    response = {\"ScheduleJobID\": schedule_job_id}\n\n                    if schedule_job_id != None:\n                        return {\n                            \"status\": 200,\n                            \"response\": str(response)\n                        }\n                    else:\n                        return {\n                            \"status\": 400,\n                            \"message\":  f\"FAILED: {scheduler.message}\"\n                        }\n            except Exception as ex:\n                logging.error(str(ex))\n                return {\n                     \"message\" : ex\n                }\n        else:\n            return {\n                \"status\": 400,\n                \"message\": \"'BipID' is a required parameter\"\n            }\n\nresult = main(reqBody)\n",
				"imports":[
					"requests",
					"zeep",
					"urllib3",
					"pyodbc",
					"pandas"
				],
				"isAsync":false,
				"python_version":"3.12",
				"captureStdOutput":false,
				"parameters":{
					"reqBody":"{{ n_zWwTH.outputs.body }}"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Python script",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":917,
				"resourceName":"callables_return_response_to_api",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_nz9mE-1",
			"id":"n_ES15y",
			"index":3,
			"inputs":{
				"streamingCompleted":true,
				"responseName":"200_undefined",
				"body":"{{ n_7doD3.outputs.result }}",
				"status":200
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to API request",
			"type":"STOP"
		}
	],
	"ownerUserId":44105,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":false,
	"tags":[
		"virtusa"
	],
	"version":19
}