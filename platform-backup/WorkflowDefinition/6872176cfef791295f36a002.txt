{
	"appsUsed":[
		"storage_by_unifyapps"
	],
	"createdTime":1752514748890,
	"deleted":false,
	"deploymentState":{
		"deployedAt":1758646572754,
		"deployedBy":0,
		"deployedDefinitionId":"68d2d12cbd00df618e363d6c",
		"status":"DEPLOYED",
		"version":45,
		"workflowVersion":85
	},
	"edges":[
		{
			"fromNodeId":"GpPp2",
			"priority":0,
			"skip":false,
			"toNodeId":"_GK3Mq",
			"type":"next"
		},
		{
			"fromNodeId":"_GK3Mq",
			"priority":0,
			"skip":false,
			"toNodeId":"_PMUwM",
			"type":"next"
		},
		{
			"fromNodeId":"_PMUwM",
			"priority":0,
			"skip":false,
			"toNodeId":"fc5LR",
			"type":"next"
		},
		{
			"fromNodeId":"fc5LR",
			"priority":0,
			"skip":false,
			"toNodeId":"LnUU4",
			"type":"next"
		},
		{
			"fromNodeId":"LnUU4",
			"priority":0,
			"skip":false,
			"toNodeId":"BWDmq",
			"type":"next"
		},
		{
			"fromNodeId":"BWDmq",
			"priority":0,
			"skip":false,
			"toNodeId":"W8L0o",
			"type":"next"
		},
		{
			"fromNodeId":"W8L0o",
			"priority":0,
			"skip":false,
			"toNodeId":"o9ReY",
			"type":"next"
		},
		{
			"fromNodeId":"o9ReY",
			"priority":0,
			"skip":false,
			"toNodeId":"_RzKDe",
			"type":"next"
		},
		{
			"fromNodeId":"_RzKDe",
			"name":"yes",
			"priority":0,
			"skip":false,
			"toNodeId":"n_5mbgp",
			"type":"if"
		},
		{
			"fromNodeId":"n_5mbgp",
			"name":"yes",
			"priority":0,
			"skip":false,
			"toNodeId":"n_peIRh",
			"type":"if"
		},
		{
			"fromNodeId":"n_peIRh",
			"priority":0,
			"skip":false,
			"toNodeId":"_ccIJm",
			"type":"next"
		},
		{
			"fromNodeId":"n_5mbgp",
			"name":"no",
			"priority":0,
			"skip":false,
			"toNodeId":"_ccIJm",
			"type":"next"
		},
		{
			"fromNodeId":"_ccIJm",
			"priority":0,
			"skip":false,
			"toNodeId":"5WW8f",
			"type":"next"
		},
		{
			"fromNodeId":"_RzKDe",
			"name":"no",
			"priority":0,
			"skip":false,
			"toNodeId":"5WW8f",
			"type":"next"
		},
		{
			"fromNodeId":"5WW8f",
			"name":"yes",
			"priority":0,
			"skip":false,
			"toNodeId":"klqHO",
			"type":"if"
		},
		{
			"fromNodeId":"klqHO",
			"priority":0,
			"skip":false,
			"toNodeId":"UqZEe",
			"type":"next"
		},
		{
			"fromNodeId":"UqZEe",
			"priority":0,
			"skip":false,
			"toNodeId":"0wKlM",
			"type":"next"
		},
		{
			"fromNodeId":"5WW8f",
			"name":"no",
			"priority":0,
			"skip":false,
			"toNodeId":"_inC8l",
			"type":"next"
		},
		{
			"fromNodeId":"_inC8l",
			"priority":0,
			"skip":false,
			"toNodeId":"n_oeELF",
			"type":"next"
		},
		{
			"fromNodeId":"n_oeELF",
			"name":"yes",
			"priority":0,
			"skip":false,
			"toNodeId":"_eTDpB",
			"type":"if"
		},
		{
			"fromNodeId":"_eTDpB",
			"priority":0,
			"skip":false,
			"toNodeId":"_yoKTq",
			"type":"next"
		},
		{
			"fromNodeId":"n_oeELF",
			"name":"no",
			"priority":0,
			"skip":false,
			"toNodeId":"_yoKTq",
			"type":"next"
		},
		{
			"fromNodeId":"0wKlM",
			"priority":0,
			"skip":false,
			"toNodeId":"_riX3H",
			"type":"next"
		},
		{
			"fromNodeId":"_yoKTq",
			"priority":0,
			"skip":false,
			"toNodeId":"_riX3H",
			"type":"next"
		},
		{
			"fromNodeId":"_riX3H",
			"priority":0,
			"skip":false,
			"toNodeId":"nJq8F",
			"type":"next"
		},
		{
			"fromNodeId":"nJq8F",
			"priority":0,
			"skip":false,
			"toNodeId":"3RHvi",
			"type":"next"
		},
		{
			"fromNodeId":"3RHvi",
			"name":"yes",
			"priority":0,
			"skip":false,
			"toNodeId":"s2ccP",
			"type":"if"
		},
		{
			"fromNodeId":"3RHvi",
			"name":"no",
			"priority":0,
			"skip":false,
			"toNodeId":"Ze80q",
			"type":"next"
		},
		{
			"fromNodeId":"s2ccP",
			"priority":0,
			"skip":false,
			"toNodeId":"_GgFEO",
			"type":"next"
		},
		{
			"fromNodeId":"Ze80q",
			"priority":0,
			"skip":false,
			"toNodeId":"_GgFEO",
			"type":"next"
		},
		{
			"fromNodeId":"_GgFEO",
			"priority":0,
			"skip":false,
			"toNodeId":"n_WO2Rx",
			"type":"next"
		},
		{
			"fromNodeId":"n_WO2Rx",
			"priority":0,
			"skip":false,
			"toNodeId":"_Wjjil",
			"type":"next"
		},
		{
			"fromNodeId":"_Wjjil",
			"priority":0,
			"skip":false,
			"toNodeId":"rp0ma",
			"type":"next"
		},
		{
			"fromNodeId":"rp0ma",
			"priority":0,
			"skip":false,
			"toNodeId":"JxHiB",
			"type":"next"
		},
		{
			"fromNodeId":"JxHiB",
			"priority":0,
			"skip":false,
			"toNodeId":"4pZYn",
			"type":"next"
		},
		{
			"fromNodeId":"4pZYn",
			"priority":0,
			"skip":false,
			"toNodeId":"af1tm",
			"type":"next"
		},
		{
			"fromNodeId":"af1tm",
			"name":"yes",
			"priority":0,
			"skip":false,
			"toNodeId":"SgyMl",
			"type":"if"
		},
		{
			"fromNodeId":"SgyMl",
			"priority":0,
			"skip":false,
			"toNodeId":"vHto4",
			"type":"next"
		},
		{
			"fromNodeId":"vHto4",
			"priority":0,
			"skip":false,
			"toNodeId":"_yAylI",
			"type":"next"
		},
		{
			"fromNodeId":"af1tm",
			"name":"no",
			"priority":0,
			"skip":false,
			"toNodeId":"_yAylI",
			"type":"next"
		},
		{
			"fromNodeId":"_yAylI",
			"priority":0,
			"skip":false,
			"toNodeId":"n_IbUJ4",
			"type":"next"
		},
		{
			"fromNodeId":"n_IbUJ4",
			"name":"yes",
			"priority":0,
			"skip":false,
			"toNodeId":"n_l4M3Q",
			"type":"if"
		},
		{
			"fromNodeId":"n_l4M3Q",
			"priority":0,
			"skip":false,
			"toNodeId":"n_YQP58",
			"type":"next"
		},
		{
			"fromNodeId":"n_YQP58",
			"priority":0,
			"skip":false,
			"toNodeId":"_UuNZv",
			"type":"next"
		},
		{
			"fromNodeId":"n_IbUJ4",
			"name":"no",
			"priority":0,
			"skip":false,
			"toNodeId":"_UuNZv",
			"type":"next"
		}
	],
	"grants":{
		"configs":[
			{
				"permissions":[
					"V"
				],
				"principalType":"GLOBAL"
			}
		]
	},
	"id":"6872176cfef791295f36a002",
	"lastModifiedBy":0,
	"lcName":"executesql tool",
	"modifiedTime":1758655395178,
	"name":"ExecuteSQL Tool",
	"nodes":[
		{
			"context":{
				"appName":"callables",
				"resourceVersion":16,
				"resourceName":"callables_from_interface"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"GpPp2",
			"index":1,
			"inputs":{
				"result":{
					"additionalProperties":false,
					"ua:modal":{
						"field_type":"STRING",
						"is_optional":true
					},
					"type":"object",
					"properties":{
						"toolOutput":{
							"type":"string",
							"title":"toolOutput"
						},
						"success":{
							"type":"boolean",
							"title":"Success"
						},
						"error":{
							"type":"string",
							"title":"Error"
						}
					},
					"required":[]
				},
				"callableInterfaceId":"679484ef9c8ab5620dca9609",
				"setup":{
					"additionalProperties":false,
					"ua:modal":{
						"field_type":"STRING",
						"is_optional":true
					},
					"type":"object",
					"properties":{
						"toolId":{
							"type":"string",
							"title":"toolId"
						},
						"toolInputs":{
							"type":"object",
							"title":"toolInputs"
						},
						"triggeredByAgentId":{
							"type":"string",
							"title":"Triggered By Agent Id"
						},
						"agentResponseMessageId":{
							"type":"string",
							"title":"Agent Response Message Id"
						},
						"caseId":{
							"type":"string",
							"title":"Case Id"
						},
						"executeUsingModel":{
							"type":"string",
							"title":"Execute Using Model"
						},
						"toolName":{
							"type":"string",
							"title":"Tool Name"
						},
						"actionId":{
							"type":"string",
							"title":"Action Id"
						},
						"toolAdditional":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Tool Additional"
						}
					},
					"required":[]
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Trigger interface",
			"trigger":{
				"type":"CALLABLE"
			},
			"type":"START"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":11,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"_GK3Mq",
			"index":2,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"sql_query":{
							"type":"string",
							"title":"Sql Query"
						},
						"platformName":{
							"type":"string",
							"title":"Platform Name"
						},
						"metadata":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{},
								"additionalProperties":false,
								"required":[]
							},
							"title":"Metadata"
						},
						"blocks":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Blocks"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"input":{
					"type":"object",
					"properties":{
						"toolInputs":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Tool Inputs"
						},
						"toolAdditional":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Tool Additional"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"compile_static":false,
				"code":"def sql_query = null\ndef platformName = null\ndef metadata = null\ndef blocks = null\n\nif(binding.hasVariable('toolInputs')){\n  sql_query = toolInputs?.sql_query\n  blocks = toolInputs?.toBlocks\n}\nif(binding.hasVariable('toolAdditional')){\n  platformName = toolAdditional?.platformName\n  metadata = toolAdditional?.metadata\n}\nreturn [sql_query: sql_query, platformName: platformName, metadata: metadata, blocks: blocks]",
				"parameters":{
					"toolInputs":"{{ GpPp2.outputs.toolInputs }}",
					"toolAdditional":"{{ GpPp2.outputs.toolAdditional }}"
				}
			},
			"skip":false,
			"subTitle":"Get query",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"additional":{
				"visibleOptionalFields":[
					"root.parameters.md.items"
				]
			},
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":184,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"_PMUwM",
			"index":3,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"metadata":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{
									"tableName":{
										"type":"string",
										"title":"Table Name"
									},
									"columns":{
										"type":"array",
										"items":{
											"type":"object",
											"properties":{},
											"additionalProperties":false
										},
										"title":"Columns"
									},
									"tableDescription":{
										"type":"string",
										"title":"Table Description"
									},
									"tablePrimaryKey":{
										"type":"string",
										"title":"Table Primary Key"
									},
									"platform_name":{
										"type":"string",
										"title":"Platform Name"
									},
									"tableNameUI":{
										"type":"string",
										"title":"Table Name UI"
									}
								},
								"additionalProperties":false,
								"required":[]
							},
							"title":"metadata"
						},
						"metadata_reduced":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Metadata Reduced"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"input":{
					"type":"object",
					"properties":{
						"md":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"md"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"compile_static":false,
				"code":"def tableMap = [:]\n\ndef md = binding.hasVariable(\"md\") ? binding.getVariable(\"md\") : []\n\nmd.each { metadataItem ->\n    def tableName = metadataItem['table_name']\n    if (!tableMap.containsKey(tableName)) {\n        tableMap[tableName] = [\n            'columns': [],\n            'tableDescription': metadataItem['tableDescription'],\n            'tablePrimaryKey': metadataItem['tablePrimaryKey'],\n            'platform_name': metadataItem['platform_name'],\n            'tableNameUI': metadataItem['tableNameUI']\n        ]\n    }    \n    def filteredMetadata = [\n        'column_description': metadataItem?.column_description?.replace(\"\\n\", \"<br>\"),\n        'column_name': metadataItem?.column_name,\n        'column_datatype': metadataItem?.column_datatype,\n        'column_label' : metadataItem?.column_label,\n    ]\n    \n    tableMap[tableName]['columns'] << filteredMetadata\n}\n\ndef resultArray = tableMap.collect { tableName, data ->\n    [\n        'tableName': tableName,\n        'columns': data['columns'],\n        'tableDescription': data['tableDescription'],\n        'tablePrimaryKey': data['tablePrimaryKey'],\n        'platform_name': data['platform_name'],\n        'tableNameUI': data['tableNameUI']\n    ]\n}\ndef reducedResultArray = tableMap.collect { tableName, data ->\n    [\n        'tableName': tableName,\n        'columns': data['columns'].collect { col ->\n            [\n                'column_name': col['column_name'],\n                'column_label': col['column_label']\n                // column_description and column_datatype are not included\n            ]\n        },\n        'tableDescription': data['tableDescription'],\n        'tablePrimaryKey': data['tablePrimaryKey'],\n        'platform_name': data['platform_name'],\n        'tableNameUI': data['tableNameUI']\n    ]\n}\n\nreturn [\n    'metadata': resultArray,\n    'metadata_reduced': reducedResultArray\n]\n\n\nreturn ['metadata': resultArray,'metadata_reduced' : reducedResultArray]",
				"parameters":{
					"md":{
						"ua:type":"mappedArray",
						"source":"{{ _GK3Mq.outputs.result.metadata }}",
						"items":"{{ _GK3Mq.outputs.result.metadata[0] }}"
					}
				}
			},
			"skip":false,
			"subTitle":"convert metadata",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":124,
				"resourceName":"callables_call_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"fc5LR",
			"index":4,
			"inputs":{
				"automationId":"67c89525ab51f86320c5f5f1",
				"runtimeConnections":{},
				"synchronous":false,
				"version":"-1",
				"parameters":{
					"caseId":"{{ GpPp2.outputs.caseId }}",
					"queries":{
						"items":"{{ Oqpz0.outputs.result.sql_query }}",
						"ua:type":"mappedArray"
					}
				}
			},
			"skip":false,
			"subTitle":"searching",
			"title":"Call automation",
			"type":"CALL_WORKFLOW"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":317,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"LnUU4",
			"index":5,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"limited_sql":{
							"type":"string",
							"title":"limited_sql"
						},
						"userLimits":{
							"type":"boolean",
							"title":"userLimits"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"input":{
					"type":"object",
					"properties":{
						"sql_query":{
							"type":"string",
							"title":"sql_query"
						},
						"max_row_limit":{
							"type":"integer",
							"title":"Max Row Limit"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"compile_static":false,
				"code":"import java.util.regex.Pattern\n\ndef pattern = Pattern.compile(\"\\\\blimit\\\\b\", Pattern.CASE_INSENSITIVE)\ndef matcher = pattern.matcher(sql_query)\ndef userLimits = matcher.find()\n\ndef limit = 50\nif(binding.hasVariable(\"max_row_limit\")){\n    limit = max_row_limit + 5\n}\ndef limit_str = limit.toString()\n\ndef result\nif (userLimits) {\n    result = [\n        limited_sql: (String) sql_query.toString(),\n        userLimits: true\n    ]\n} else {\n    String sql = sql_query.replaceAll(/[ \\t\\n;]+$/, '').toString()\n    result = [\n        limited_sql: (String) \"${sql} LIMIT ${limit_str}\",\n        userLimits: false\n    ]\n}\n\nreturn result",
				"parameters":{
					"max_row_limit":20,
					"sql_query":"{{ _GK3Mq.outputs.result.sql_query }}"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":238,
				"resourceName":"variable_by_unifyapps_create_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"BWDmq",
			"index":6,
			"inputSchema":{
				"type":"SCHEMA_AND_LAYOUT",
				"dynamic":false,
				"layout":{},
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"finalSQLquery":{
							"type":"string",
							"title":"finalSQLquery"
						}
					},
					"required":[]
				}
			},
			"inputs":{},
			"outputSchema":{
				"dynamic":false,
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"finalSQLquery":{
							"type":"string",
							"title":"finalSQLquery"
						},
						"_ua_variableDetails":{
							"items":{
								"properties":{
									"name":{
										"type":"string",
										"description":"Name of the variable"
									},
									"dataType":{
										"type":"string",
										"description":"Data type of the variable"
									},
									"description":{
										"type":"string",
										"description":"Description of the variable"
									}
								},
								"type":"object"
							},
							"title":"Variable Details",
							"type":"array"
						}
					},
					"required":[]
				}
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Create variables",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":16,
				"resourceName":"variable_by_unifyapps_create_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"W8L0o",
			"index":7,
			"inputSchema":{
				"type":"SCHEMA_AND_LAYOUT",
				"dynamic":false,
				"layout":{},
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"sql_with_limit":{
							"type":"string",
							"title":"sql_with_limit"
						},
						"sql_to_cache":{
							"type":"string",
							"title":"sql_to_cache"
						}
					},
					"required":[]
				}
			},
			"inputs":{
				"sql_to_cache":"{{ _GK3Mq.outputs.result.sql_query }}",
				"sql_with_limit":"{{ LnUU4.outputs.result.limited_sql }}"
			},
			"outputSchema":{
				"dynamic":false,
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"sql_with_limit":{
							"type":"string",
							"title":"sql_with_limit"
						},
						"sql_to_cache":{
							"type":"string",
							"title":"sql_to_cache"
						},
						"_ua_variableDetails":{
							"items":{
								"properties":{
									"name":{
										"type":"string",
										"description":"Name of the variable"
									},
									"dataType":{
										"type":"string",
										"description":"Data type of the variable"
									},
									"description":{
										"type":"string",
										"description":"Description of the variable"
									}
								},
								"type":"object"
							},
							"title":"Variable Details",
							"type":"array"
						}
					},
					"required":[]
				}
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Create variables",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":316,
				"resourceName":"callables_call_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"CONTINUE",
			"groupId":"kFhpo-1",
			"id":"o9ReY",
			"index":8,
			"inputs":{
				"automationId":"6805ed8f0b23cb21fda8bb24",
				"runtimeConnections":{},
				"synchronous":true,
				"version":"-1",
				"parameters":{
					"platformName":"{{ Oqpz0.outputs.result.platformName }}",
					"sqlQuery":"{{ LnUU4.outputs.result.limited_sql }}"
				}
			},
			"options":{
				"businessHoursConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"cacheConfig":{
					"enabled":false
				},
				"circuitBreakerConfig":{
					"enabled":false
				},
				"disableLogging":false,
				"enabledForReExecution":false,
				"hookConfig":{
					"enabled":false
				},
				"logConfig":{
					"enabled":false
				},
				"rateLimitConfig":{
					"enabled":false,
					"waitForNextWindow":false
				},
				"retryConfig":{
					"backOffFactor":null,
					"captureRetries":false,
					"enabled":false
				},
				"stepError":"CONTINUE",
				"telemetryConfig":{
					"enableTelemetry":false
				}
			},
			"skip":false,
			"subTitle":"Run Query On SQL Based Platforms",
			"title":"Call automation",
			"type":"CALL_WORKFLOW"
		},
		{
			"context":{
				"appName":"if_else",
				"resourceVersion":757,
				"resourceName":"if_else_condition",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"_RzKDe",
			"index":9,
			"inputs":{
				"filters":[
					{
						"property":"{{ o9ReY.outputs.rows }}",
						"filter":{
							"operator":"MISSING"
						}
					},
					{
						"property":"=LEN({{ o9ReY.outputs.rows }})",
						"filter":{
							"operator":"EQUAL",
							"value":"0"
						}
					}
				],
				"operator":"OR"
			},
			"skip":false,
			"subTitle":"Condition",
			"title":"Condition",
			"type":"IF_ELSE"
		},
		{
			"context":{
				"appName":"if_else",
				"resourceVersion":16,
				"resourceName":"if_else_condition",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_RzKDe@kFhpo-1@y",
			"id":"n_5mbgp",
			"index":10,
			"inputs":{
				"filters":[
					{
						"property":"{{ o9ReY.outputs.status }}",
						"filter":{
							"operator":"EQUAL",
							"value":"NO"
						}
					},
					{
						"property":"{{ o9ReY.outputs.status }}",
						"filter":{
							"operator":"EQUAL",
							"value":"false"
						}
					}
				],
				"operator":"OR"
			},
			"skip":false,
			"subTitle":"Condition",
			"title":"Condition",
			"type":"IF_ELSE"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":17,
				"resourceName":"callables_return_to_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_5mbgp@_RzKDe@kFhpo-1@y@y",
			"id":"n_peIRh",
			"index":11,
			"inputs":{
				"result":{
					"success":false,
					"error":"{{ o9ReY.outputs.err_msg }}"
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to automation",
			"type":"STOP"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":797,
				"resourceName":"callables_return_to_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"_RzKDe@kFhpo-1@y",
			"id":"_ccIJm",
			"index":12,
			"inputs":{
				"result":{
					"toolOutput":"The data queried from this SQL query is empty. Try generating a more generic SQL query or clarify/ask the user to rephrase the question asked.",
					"success":true
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to automation",
			"type":"STOP"
		},
		{
			"context":{
				"appName":"if_else",
				"resourceVersion":300,
				"resourceName":"if_else_condition",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"5WW8f",
			"index":13,
			"inputs":{
				"filters":[
					{
						"property":"{{ o9ReY.outputs.err_msg }}",
						"filter":{
							"operator":"MISSING"
						}
					}
				],
				"operator":"AND"
			},
			"skip":false,
			"subTitle":"Condition",
			"title":"Condition",
			"type":"IF_ELSE"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":73,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"5WW8f@kFhpo-1@y",
			"id":"klqHO",
			"index":14,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"finalCache":{
							"type":"string",
							"title":"finalCache"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"input":{
					"type":"object",
					"properties":{
						"limited":{
							"type":"string",
							"title":"limited"
						},
						"to_cache":{
							"type":"string",
							"title":"to_cache"
						},
						"originalQuery":{
							"type":"string",
							"title":"originalQuery"
						}
					},
					"additionalProperties":false
				},
				"compile_static":false,
				"code":"import java.util.regex.*\n\nboolean userLimits = (originalQuery =~ /(?i)\\blimit\\b/).find()\n\ndef result\nif (userLimits) {\n    result = [finalCache: limited]\n} else {\n    // Remove LIMIT clause `[spaces]limit <something>[spaces][optional offset or end]`\n    def pattern = ~/(?i)\\s*limit\\s+\\S+\\s*(?=offset|\\Z|;)/\n    def sql_no_limit = to_cache.replaceAll(pattern, '').replaceAll(/[\\s;]+$/, '')\n    result = [finalCache: sql_no_limit]\n}\nreturn result",
				"parameters":{
					"to_cache":"{{ W8L0o.outputs.sql_to_cache }}",
					"limited":"{{ W8L0o.outputs.sql_with_limit }}",
					"originalQuery":"{{ _GK3Mq.outputs.result.sql_query }}"
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"additional":{
				"xsdSchemaConfig":{},
				"visibleOptionalFields":[
					"root.parameters.metadata.items.tableName",
					"root.parameters.metadata.items.platformName",
					"root.parameters.metadata.items.tableNameUI"
				]
			},
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":380,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"5WW8f@kFhpo-1@y",
			"id":"UqZEe",
			"index":15,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"tableUsed":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{
									"platformName":{
										"type":"string",
										"title":"platformName"
									},
									"tableName":{
										"type":"string",
										"title":"tableName"
									},
									"tableNameUI":{
										"type":"string",
										"title":"tableNameUI"
									}
								},
								"additionalProperties":false
							},
							"title":"tableUsed"
						}
					},
					"additionalProperties":false
				},
				"input":{
					"type":"object",
					"properties":{
						"sql":{
							"type":"string",
							"title":"Sql"
						},
						"metadata":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{
									"tableName":{
										"type":"string",
										"title":"Table Name"
									},
									"platformName":{
										"type":"string",
										"title":"Platform Name"
									},
									"tableNameUI":{
										"type":"string",
										"title":"Table Name UI"
									}
								},
								"additionalProperties":false,
								"required":[]
							},
							"title":"Metadata"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"compile_static":false,
				"code":"def extractTableNamesFromSQL(String sql) {\n    def normSql = sql\n        .replaceAll('\\\\\\\\n', ' ')\n        .replaceAll('\\\\\\\\r', ' ')\n        .replaceAll('\\\\\\\\t', ' ')\n        .replaceAll('\\\\s+', ' ')\n\n    def matcher = (normSql =~ /\\b(FROM|JOIN)\\s+([a-zA-Z0-9_.]+)/)\n    def tableNames = [] as Set\n    matcher.each { tableNames << it[2] }\n    return tableNames ? tableNames as List : []\n}\n\n// Extract table names from SQL\ndef tableList = extractTableNamesFromSQL(sql)\n\n// For each table, just take the *first* matching metadata object\ndef result = tableList.collect { tbl ->\n    metadata.find { it.tableName == tbl }\n}.findAll { it } // In case there are no matches for some table names\n\nreturn [tableUsed: result]",
				"parameters":{
					"sql":"{{ W8L0o.outputs.sql_to_cache }}",
					"metadata":{
						"ua:type":"mappedArray",
						"items":{
							"tableName":"{{ _PMUwM.outputs.result.metadata[0].tableName }}",
							"platformName":"{{ _PMUwM.outputs.result.metadata[0].platform_name }}",
							"tableNameUI":"{{ _PMUwM.outputs.result.metadata[0].tableNameUI }}"
						},
						"source":"{{ _PMUwM.outputs.result.metadata }}"
					}
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":236,
				"resourceName":"variable_by_unifyapps_update_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"5WW8f@kFhpo-1@y",
			"id":"0wKlM",
			"index":16,
			"inputs":{
				"variables":[
					{
						"source":"{{ BWDmq.outputs.finalSQLquery }}",
						"value":"{{ W8L0o.outputs.sql_to_cache }}"
					}
				]
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Update variables",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":16,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"5WW8f@kFhpo-1@n",
			"id":"_inC8l",
			"index":17,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"tables_list":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{
									"table":{
										"type":"string",
										"title":"Table"
									},
									"columns":{
										"type":"array",
										"items":{
											"type":"string"
										},
										"title":"Columns"
									}
								},
								"additionalProperties":false,
								"required":[]
							},
							"title":"tables_list"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"input":{
					"type":"object",
					"properties":{
						"sql_query":{
							"type":"string",
							"title":"sql_query"
						}
					},
					"additionalProperties":false
				},
				"compile_static":false,
				"code":"// def sql = binding.hasVariable(\"sql_query\") ? binding.getVariable(\"sql_query\") : \"\"\n\n// def transformedSql = sql\n// def extractPattern = /(?i)EXTRACT\\s*\\([^)]*\\bFROM\\b[^)]*\\)/\n// while (transformedSql =~ extractPattern) {\n//     transformedSql = transformedSql.replaceAll(extractPattern, 'EXTRACT(1234)')\n// }\n\n// // // Step 2: Extract join information\n// // def joinPairs = []\n// // def joinPattern = /(?i)\\b(?:LEFT\\s+)?JOIN\\b\\s+([\\w.]+)(?:\\s+(\\w+))?\\s+ON\\s+([^)]+?)(?=\\s+(?:LEFT\\s+)?JOIN\\b|\\s+WHERE\\b|\\s+GROUP\\b|\\s+ORDER\\b|\\s+HAVING\\b|$)/\n// // def joinMatches = transformedSql =~ joinPattern\n// // while (joinMatches.find()) {\n// //     def rightTable = joinMatches.group(1)\n// //     def rightAlias = joinMatches.group(2)?.trim()\n// //     def onClause = joinMatches.group(3).trim()\n    \n// //     // Extract table references from ON clause\n// //     def onPattern = /(\\w+)\\.(\\w+)\\s*=\\s*(\\w+)\\.(\\w+)/\n// //     def onMatch = onClause =~ onPattern\n// //     if (onMatch.find()) {\n// //         def leftRef = onMatch.group(1)\n// //         def leftCol = onMatch.group(2)\n// //         def rightRef = onMatch.group(3)\n// //         def rightCol = onMatch.group(4)\n// //         joinPairs << [\n// //             leftTableRef: leftRef, \n// //             leftColumn: leftCol,\n// //             rightTableRef: rightRef, \n// //             rightColumn: rightCol, \n// //             rightTable: rightTable, \n// //             rightAlias: rightAlias\n// //         ]\n// //     }\n// // }\n\n// // Step 3: Build table alias map\n// def tableAliasMap = [:] // alias -> tableName\n// def regexFrom = /(?i)\\bFROM\\b\\s+([\\w.]+)(?:\\s+(\\w+))?/\n// def regexJoin = /(?i)\\b(?:LEFT\\s+)?JOIN\\b\\s+([\\w.]+)(?:\\s+(\\w+))?/\n// def columns = []\n\n// // Find main table and its alias\n// def m = (transformedSql =~ regexFrom)\n// if (m.find()) {\n//     def tableName = m.group(1)\n//     def alias = m.group(2)?.trim()\n//     tableAliasMap[(alias ?: tableName)] = tableName\n// }\n\n// // Find join tables and aliases\n// def joins = (transformedSql =~ regexJoin)\n// while (joins.find()) {\n//     def tableName = joins.group(1)\n//     def alias = joins.group(2)?.trim()\n//     tableAliasMap[(alias ?: tableName)] = tableName\n// }\n\n// // Step 4: Extract columns from SELECT clause\n// def selectMatch = (transformedSql =~ /(?i)SELECT\\s+(.*?)\\s+FROM/)\n// def selectPart = selectMatch ? (selectMatch[0][1] ?: '') : ''\n\n// // Handle column extraction more robustly\n// def columnItems = []\n// def depth = 0\n// def currentItem = new StringBuilder()\n\n// // Split by comma but respect parentheses\n// selectPart.each { ch ->\n//     if (ch == '(') depth++\n//     else if (ch == ')') depth--\n    \n//     if (ch == ',' && depth == 0) {\n//         columnItems << currentItem.toString().trim()\n//         currentItem = new StringBuilder()\n//     } else {\n//         currentItem.append(ch)\n//     }\n// }\n// if (currentItem.length() > 0) {\n//     columnItems << currentItem.toString().trim()\n// }\n\n// // Process each column item\n// columnItems.each { item ->\n//     // Remove AS alias\n//     def cleanItem = item.replaceAll(/(?i)\\s+AS\\s+\\w+/, '').trim()\n    \n//     // Check for table.column pattern\n//     def aliasColPattern = /\\b(\\w+)\\.(\\w+)\\b/\n//     def aliasColMatch = cleanItem =~ aliasColPattern\n    \n//     if (aliasColMatch.find()) {\n//         columns << [alias: aliasColMatch.group(1), column: aliasColMatch.group(2)]\n//     }\n//     // Handle * or COUNT(*)\n//     else if (cleanItem == '*' || cleanItem =~ /(?i)COUNT\\s*\\(\\s*\\*\\s*\\)/) {\n//         if (tableAliasMap.size() == 1) {\n//             columns << [alias: null, column: '*', table: tableAliasMap.values().first()]\n//         } else {\n//             columns << [alias: null, column: '*']\n//         }\n//     }\n//     // Handle SUM, AVG, MAX, MIN, COUNT with columns\n//     else if (cleanItem =~ /(?i)(SUM|AVG|MAX|MIN|COUNT)\\s*\\(([^)]+)\\)/) {\n//         def funcMatch = cleanItem =~ /(?i)(SUM|AVG|MAX|MIN|COUNT)\\s*\\(([^)]+)\\)/\n//         if (funcMatch.find()) {\n//             def innerExpr = funcMatch.group(2).trim()\n//             def innerColMatch = innerExpr =~ /\\b(\\w+)\\.(\\w+)\\b/\n//             if (innerColMatch.find()) {\n//                 columns << [alias: innerColMatch.group(1), column: innerColMatch.group(2)]\n//             }\n//         }\n//     }\n//     // Handle simple column names (only if single table)\n//     else if (tableAliasMap.size() == 1 && cleanItem =~ /^\\w+$/) {\n//         columns << [alias: null, column: cleanItem, table: tableAliasMap.values().first()]\n//     }\n// }\n\n// // Step 5: Build the output map\n// def resultMap = [:].withDefault{[]}\n// columns.each { c ->\n//     if (c.table) {\n//         resultMap[c.table] << c.column\n//     } else if (c.alias) {\n//         def table = tableAliasMap[c.alias]\n//         if (table) {\n//             resultMap[table] << c.column\n//         }\n//     } else if (tableAliasMap.size() == 1) {\n//         // No alias and single table: associate to that table\n//         resultMap[tableAliasMap.values().first()] << c.column\n//     }\n// }\n\n// // Remove duplicates\n// resultMap.each { k, v -> resultMap[k] = v.unique() }\n// def tablesList = resultMap.collect { table, cols ->\n//     [ table: table, columns: cols ]\n// }\n\n// // Step 6: Build join information with actual table names\n// // def joinInfo = []\n// // joinPairs.each { jp ->\n// //     def leftTable = tableAliasMap[jp.leftTableRef]\n// //     def rightTable = jp.rightTable\n// //     if (leftTable && rightTable) {\n// //         def leftCol = jp.leftColumn\n// //         def rightCol = jp.rightColumn\n// //         joinInfo << [\n// //             leftTable: leftTable, \n// //             leftColumn: leftCol,\n// //             rightTable: rightTable,\n// //             rightColumn: rightCol\n// //         ]\n// //     }\n// // }\n\n// // return [\n// //     // \"joins\": joinInfo,\n// //     \"tables_list\": resultMap\n// // ]\n\n\n// return [\n//     // \"joins\": joinInfo,\n//     \"tables_list\": tablesList\n// ]\n\ndef sql = binding.hasVariable(\"sql_query\") ? binding.getVariable(\"sql_query\") : \"\"\n\ndef transformedSql = sql\ndef extractPattern = /(?i)EXTRACT\\s*\\([^)]*\\bFROM\\b[^)]*\\)/\nwhile (transformedSql =~ extractPattern) {\n    transformedSql = transformedSql.replaceAll(extractPattern, 'EXTRACT(1234)')\n}\n\n// Step 3: Build table alias map\ndef tableAliasMap = [:] // alias -> tableName\ndef regexFrom = /(?i)\\bFROM\\b\\s+([\\w.]+)(?:\\s+(\\w+))?/\ndef regexJoin = /(?i)\\b(?:LEFT\\s+)?JOIN\\b\\s+([\\w.]+)(?:\\s+(\\w+))?/\ndef columns = []\n\n// Find main table and its alias\ndef m = (transformedSql =~ regexFrom)\nif (m.find()) {\n    def tableName = m.group(1)\n    def alias = m.group(2)?.trim()\n    tableAliasMap[(alias ?: tableName)] = tableName\n}\n\n// Find join tables and aliases\ndef joins = (transformedSql =~ regexJoin)\nwhile (joins.find()) {\n    def tableName = joins.group(1)\n    def alias = joins.group(2)?.trim()\n    tableAliasMap[(alias ?: tableName)] = tableName\n}\n\n// Step 4: Extract columns from SELECT clause\ndef selectMatch = (transformedSql =~ /(?i)SELECT\\s+(.*?)\\s+FROM/)\ndef selectPart = selectMatch ? (selectMatch[0][1] ?: '') : ''\nselectPart = selectPart\n    .replaceFirst(/(?i)^\\s*DISTINCT\\s+ON\\s*\\([^)]*\\)\\s*/, '')\n    .replaceFirst(/(?i)^\\s*(ALL|DISTINCT)\\b\\s*/, '')\n// Handle column extraction more robustly\ndef columnItems = []\ndef depth = 0\ndef currentItem = new StringBuilder()\n\n// Split by comma but respect parentheses\nselectPart.each { ch ->\n    if (ch == '(') depth++\n    else if (ch == ')') depth--\n    \n    if (ch == ',' && depth == 0) {\n        columnItems << currentItem.toString().trim()\n        currentItem = new StringBuilder()\n    } else {\n        currentItem.append(ch)\n    }\n}\nif (currentItem.length() > 0) {\n    columnItems << currentItem.toString().trim()\n}\n\n// Process each column item\ncolumnItems.each { item ->\n    // Remove AS alias\n    def cleanItem = item.replaceAll(/(?i)\\s+AS\\s+\\w+/, '').trim()\n    \n    // Check for table.column pattern\n    def aliasColPattern = /\\b(\\w+)\\.(\\w+)\\b/\n    def aliasColMatch = cleanItem =~ aliasColPattern\n    \n    if (aliasColMatch.find()) {\n        columns << [alias: aliasColMatch.group(1), column: aliasColMatch.group(2)]\n    }\n    // Handle * or COUNT(*)\n    else if (cleanItem == '*' || cleanItem =~ /(?i)COUNT\\s*\\(\\s*\\*\\s*\\)/) {\n        if (tableAliasMap.size() == 1) {\n            columns << [alias: null, column: '*', table: tableAliasMap.values().first()]\n        } else {\n            columns << [alias: null, column: '*']\n        }\n    }\n    // Handle SUM, AVG, MAX, MIN, COUNT with DISTINCT and columns\n    else if (cleanItem =~ /(?i)(SUM|AVG|MAX|MIN|COUNT)\\s*\\(\\s*(DISTINCT\\s+)?([^)]+)\\s*\\)/) {\n        def funcMatch = cleanItem =~ /(?i)(SUM|AVG|MAX|MIN|COUNT)\\s*\\(\\s*(DISTINCT\\s+)?([^)]+)\\s*\\)/\n        if (funcMatch.find()) {\n            def innerExpr = funcMatch.group(3)?.trim()\n            def innerColMatch = innerExpr =~ /\\b(\\w+)\\.(\\w+)\\b/\n            if (innerColMatch.find()) {\n                columns << [alias: innerColMatch.group(1), column: innerColMatch.group(2)]\n            } else if (tableAliasMap.size() == 1 && innerExpr =~ /^\\w+$/) {\n                columns << [alias: null, column: innerExpr, table: tableAliasMap.values().first()]\n            }\n        }\n    }\n    // Handle simple column names (only if single table)\n    else if (tableAliasMap.size() == 1 && cleanItem =~ /^\\w+$/) {\n        columns << [alias: null, column: cleanItem, table: tableAliasMap.values().first()]\n    }\n}\n\n// Step 5: Build the output map\ndef resultMap = [:].withDefault{[]}\ncolumns.each { c ->\n    if (c.table) {\n        resultMap[c.table] << c.column\n    } else if (c.alias) {\n        def table = tableAliasMap[c.alias]\n        if (table) {\n            resultMap[table] << c.column\n        }\n    } else if (tableAliasMap.size() == 1) {\n        // No alias and single table: associate to that table\n        resultMap[tableAliasMap.values().first()] << c.column\n    }\n}\n\n// Remove duplicates\nresultMap.each { k, v -> resultMap[k] = v.unique() }\ndef tablesList = resultMap.collect { table, cols ->\n    [ table: table, columns: cols ]\n}\n\nreturn [\n    \"tables_list\": tablesList\n]\n",
				"parameters":{
					"sql_query":"{{ BWDmq.outputs.finalSQLquery }}"
				}
			},
			"skip":false,
			"subTitle":"extract info",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"if_else",
				"resourceVersion":20,
				"resourceName":"if_else_condition",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"5WW8f@kFhpo-1@n",
			"id":"n_oeELF",
			"index":18,
			"inputs":{
				"filters":[
					{
						"property":"{{ o9ReY.outputs.err_msg }}",
						"filter":{
							"operator":"EQUAL",
							"value":"The SQL Query is taking time. So, we will post the result to you via mail. You can continue the chat. Would you like to know anything else."
						}
					}
				],
				"operator":"AND"
			},
			"skip":false,
			"subTitle":"Condition",
			"title":"Condition",
			"type":"IF_ELSE"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":17,
				"resourceName":"callables_return_to_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_oeELF@5WW8f@kFhpo-1@n@y",
			"id":"_eTDpB",
			"index":19,
			"inputs":{
				"result":{
					"success":false,
					"error":"{{ o9ReY.outputs.err_msg }}"
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to automation",
			"type":"STOP"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":17,
				"resourceName":"callables_return_to_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"5WW8f@kFhpo-1@n",
			"id":"_yoKTq",
			"index":20,
			"inputs":{
				"result":{
					"success":false,
					"error":"{{ o9ReY.outputs.err_msg }}. Columns and tables as extracted from the sql formed :{{ _inC8l.outputs.result.tables_list }}; Check if query is made using wrong columns from wrong table, or joins are made b/w wrong tables or join is performed on the wrong attribute. For just once try regeneration of the correct query, correcting the columns/views/joins/tables."
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to automation",
			"type":"STOP"
		},
		{
			"additional":{
				"xsdSchemaConfig":{},
				"visibleOptionalFields":[
					"root.parameters.rows.items",
					"root.parameters.cols.items"
				]
			},
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":78,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"_riX3H",
			"index":21,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"rowData":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{},
								"additionalProperties":false
							},
							"title":"Row Data"
						},
						"countRows":{
							"type":"integer",
							"title":"countRows"
						},
						"max_limit":{
							"type":"integer",
							"title":"Max Limit"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"input":{
					"type":"object",
					"properties":{
						"rows":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{},
								"additionalProperties":false
							},
							"title":"rows"
						},
						"max_row_limit":{
							"type":"integer",
							"title":"Max Row Limit"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"compile_static":false,
				"code":"def limit = 25\nif (binding.hasVariable(\"max_row_limit\")) {\n    limit = max_row_limit\n}\n\nif (binding.hasVariable(\"rows\")) {\n    return [\n        \"countRows\" : rows.size(),\n        \"rowData\"   : rows.take(limit),\n        \"max_limit\" : limit\n    ]\n} else {\n    return [\n        \"countRows\" : 0,\n        \"rowData\"   : [],\n        \"max_limit\" : limit\n    ]\n}",
				"isAsync":false,
				"parameters":{
					"rows":{
						"source":"{{ o9ReY.outputs.rows }}",
						"ua:type":"mappedArray",
						"items":"{{ o9ReY.outputs.rows[0] }}"
					},
					"max_row_limit":20
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":238,
				"resourceName":"variable_by_unifyapps_create_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"nJq8F",
			"index":22,
			"inputSchema":{
				"type":"SCHEMA_AND_LAYOUT",
				"dynamic":false,
				"layout":{},
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"hasMoreData":{
							"type":"boolean",
							"title":"hasMoreData"
						}
					},
					"required":[]
				}
			},
			"inputs":{},
			"outputSchema":{
				"dynamic":false,
				"schema":{
					"additionalProperties":false,
					"type":"object",
					"properties":{
						"hasMoreData":{
							"type":"boolean",
							"title":"hasMoreData"
						},
						"_ua_variableDetails":{
							"items":{
								"properties":{
									"name":{
										"type":"string",
										"description":"Name of the variable"
									},
									"dataType":{
										"type":"string",
										"description":"Data type of the variable"
									},
									"description":{
										"type":"string",
										"description":"Description of the variable"
									}
								},
								"type":"object"
							},
							"title":"Variable Details",
							"type":"array"
						}
					},
					"required":[]
				}
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Create variables",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"if_else",
				"resourceVersion":231,
				"resourceName":"if_else_condition",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"3RHvi",
			"index":23,
			"inputs":{
				"filters":[
					{
						"property":"{{ _riX3H.outputs.result.countRows }}",
						"filter":{
							"operator":"LTE",
							"value":"{{ _riX3H.outputs.result.max_limit }}"
						}
					}
				],
				"operator":"AND"
			},
			"skip":false,
			"subTitle":"Condition",
			"title":"Condition",
			"type":"IF_ELSE"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":236,
				"resourceName":"variable_by_unifyapps_update_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"3RHvi@kFhpo-1@y",
			"id":"s2ccP",
			"index":24,
			"inputs":{
				"variables":[
					{
						"source":"{{ nJq8F.outputs.hasMoreData }}",
						"value":false
					}
				]
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Update variables",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"variable_by_unifyapps",
				"resourceVersion":236,
				"resourceName":"variable_by_unifyapps_update_variables",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"3RHvi@kFhpo-1@n",
			"id":"Ze80q",
			"index":25,
			"inputs":{
				"variables":[
					{
						"source":"{{ nJq8F.outputs.hasMoreData }}",
						"value":true
					}
				]
			},
			"skip":false,
			"subTitle":"Variable by UnifyApps",
			"title":"Update variables",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":16,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"_GgFEO",
			"index":26,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"tables_list":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{
									"table":{
										"type":"string",
										"title":"Table"
									},
									"columns":{
										"type":"array",
										"items":{
											"type":"string"
										},
										"title":"Columns"
									}
								},
								"additionalProperties":false,
								"required":[]
							},
							"title":"tables_list"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"input":{
					"type":"object",
					"properties":{
						"sql_query":{
							"type":"string",
							"title":"sql_query"
						}
					},
					"additionalProperties":false
				},
				"compile_static":false,
				"code":"// def sql = binding.hasVariable(\"sql_query\") ? binding.getVariable(\"sql_query\") : \"\"\n\n// def transformedSql = sql\n// def extractPattern = /(?i)EXTRACT\\s*\\([^)]*\\bFROM\\b[^)]*\\)/\n// while (transformedSql =~ extractPattern) {\n//     transformedSql = transformedSql.replaceAll(extractPattern, 'EXTRACT(1234)')\n// }\n\n// // // Step 2: Extract join information\n// // def joinPairs = []\n// // def joinPattern = /(?i)\\b(?:LEFT\\s+)?JOIN\\b\\s+([\\w.]+)(?:\\s+(\\w+))?\\s+ON\\s+([^)]+?)(?=\\s+(?:LEFT\\s+)?JOIN\\b|\\s+WHERE\\b|\\s+GROUP\\b|\\s+ORDER\\b|\\s+HAVING\\b|$)/\n// // def joinMatches = transformedSql =~ joinPattern\n// // while (joinMatches.find()) {\n// //     def rightTable = joinMatches.group(1)\n// //     def rightAlias = joinMatches.group(2)?.trim()\n// //     def onClause = joinMatches.group(3).trim()\n    \n// //     // Extract table references from ON clause\n// //     def onPattern = /(\\w+)\\.(\\w+)\\s*=\\s*(\\w+)\\.(\\w+)/\n// //     def onMatch = onClause =~ onPattern\n// //     if (onMatch.find()) {\n// //         def leftRef = onMatch.group(1)\n// //         def leftCol = onMatch.group(2)\n// //         def rightRef = onMatch.group(3)\n// //         def rightCol = onMatch.group(4)\n// //         joinPairs << [\n// //             leftTableRef: leftRef, \n// //             leftColumn: leftCol,\n// //             rightTableRef: rightRef, \n// //             rightColumn: rightCol, \n// //             rightTable: rightTable, \n// //             rightAlias: rightAlias\n// //         ]\n// //     }\n// // }\n\n// // Step 3: Build table alias map\n// def tableAliasMap = [:] // alias -> tableName\n// def regexFrom = /(?i)\\bFROM\\b\\s+([\\w.]+)(?:\\s+(\\w+))?/\n// def regexJoin = /(?i)\\b(?:LEFT\\s+)?JOIN\\b\\s+([\\w.]+)(?:\\s+(\\w+))?/\n// def columns = []\n\n// // Find main table and its alias\n// def m = (transformedSql =~ regexFrom)\n// if (m.find()) {\n//     def tableName = m.group(1)\n//     def alias = m.group(2)?.trim()\n//     tableAliasMap[(alias ?: tableName)] = tableName\n// }\n\n// // Find join tables and aliases\n// def joins = (transformedSql =~ regexJoin)\n// while (joins.find()) {\n//     def tableName = joins.group(1)\n//     def alias = joins.group(2)?.trim()\n//     tableAliasMap[(alias ?: tableName)] = tableName\n// }\n\n// // Step 4: Extract columns from SELECT clause\n// def selectMatch = (transformedSql =~ /(?i)SELECT\\s+(.*?)\\s+FROM/)\n// def selectPart = selectMatch ? (selectMatch[0][1] ?: '') : ''\n\n// // Handle column extraction more robustly\n// def columnItems = []\n// def depth = 0\n// def currentItem = new StringBuilder()\n\n// // Split by comma but respect parentheses\n// selectPart.each { ch ->\n//     if (ch == '(') depth++\n//     else if (ch == ')') depth--\n    \n//     if (ch == ',' && depth == 0) {\n//         columnItems << currentItem.toString().trim()\n//         currentItem = new StringBuilder()\n//     } else {\n//         currentItem.append(ch)\n//     }\n// }\n// if (currentItem.length() > 0) {\n//     columnItems << currentItem.toString().trim()\n// }\n\n// // Process each column item\n// columnItems.each { item ->\n//     // Remove AS alias\n//     def cleanItem = item.replaceAll(/(?i)\\s+AS\\s+\\w+/, '').trim()\n    \n//     // Check for table.column pattern\n//     def aliasColPattern = /\\b(\\w+)\\.(\\w+)\\b/\n//     def aliasColMatch = cleanItem =~ aliasColPattern\n    \n//     if (aliasColMatch.find()) {\n//         columns << [alias: aliasColMatch.group(1), column: aliasColMatch.group(2)]\n//     }\n//     // Handle * or COUNT(*)\n//     else if (cleanItem == '*' || cleanItem =~ /(?i)COUNT\\s*\\(\\s*\\*\\s*\\)/) {\n//         if (tableAliasMap.size() == 1) {\n//             columns << [alias: null, column: '*', table: tableAliasMap.values().first()]\n//         } else {\n//             columns << [alias: null, column: '*']\n//         }\n//     }\n//     // Handle SUM, AVG, MAX, MIN, COUNT with columns\n//     else if (cleanItem =~ /(?i)(SUM|AVG|MAX|MIN|COUNT)\\s*\\(([^)]+)\\)/) {\n//         def funcMatch = cleanItem =~ /(?i)(SUM|AVG|MAX|MIN|COUNT)\\s*\\(([^)]+)\\)/\n//         if (funcMatch.find()) {\n//             def innerExpr = funcMatch.group(2).trim()\n//             def innerColMatch = innerExpr =~ /\\b(\\w+)\\.(\\w+)\\b/\n//             if (innerColMatch.find()) {\n//                 columns << [alias: innerColMatch.group(1), column: innerColMatch.group(2)]\n//             }\n//         }\n//     }\n//     // Handle simple column names (only if single table)\n//     else if (tableAliasMap.size() == 1 && cleanItem =~ /^\\w+$/) {\n//         columns << [alias: null, column: cleanItem, table: tableAliasMap.values().first()]\n//     }\n// }\n\n// // Step 5: Build the output map\n// def resultMap = [:].withDefault{[]}\n// columns.each { c ->\n//     if (c.table) {\n//         resultMap[c.table] << c.column\n//     } else if (c.alias) {\n//         def table = tableAliasMap[c.alias]\n//         if (table) {\n//             resultMap[table] << c.column\n//         }\n//     } else if (tableAliasMap.size() == 1) {\n//         // No alias and single table: associate to that table\n//         resultMap[tableAliasMap.values().first()] << c.column\n//     }\n// }\n\n// // Remove duplicates\n// resultMap.each { k, v -> resultMap[k] = v.unique() }\n// def tablesList = resultMap.collect { table, cols ->\n//     [ table: table, columns: cols ]\n// }\n\n// // Step 6: Build join information with actual table names\n// // def joinInfo = []\n// // joinPairs.each { jp ->\n// //     def leftTable = tableAliasMap[jp.leftTableRef]\n// //     def rightTable = jp.rightTable\n// //     if (leftTable && rightTable) {\n// //         def leftCol = jp.leftColumn\n// //         def rightCol = jp.rightColumn\n// //         joinInfo << [\n// //             leftTable: leftTable, \n// //             leftColumn: leftCol,\n// //             rightTable: rightTable,\n// //             rightColumn: rightCol\n// //         ]\n// //     }\n// // }\n\n// // return [\n// //     // \"joins\": joinInfo,\n// //     \"tables_list\": resultMap\n// // ]\n\n\n// return [\n//     // \"joins\": joinInfo,\n//     \"tables_list\": tablesList\n// ]\n\ndef sql = binding.hasVariable(\"sql_query\") ? binding.getVariable(\"sql_query\") : \"\"\n\ndef transformedSql = sql\ndef extractPattern = /(?i)EXTRACT\\s*\\([^)]*\\bFROM\\b[^)]*\\)/\nwhile (transformedSql =~ extractPattern) {\n    transformedSql = transformedSql.replaceAll(extractPattern, 'EXTRACT(1234)')\n}\n\n// Step 3: Build table alias map\ndef tableAliasMap = [:] // alias -> tableName\ndef regexFrom = /(?i)\\bFROM\\b\\s+([\\w.]+)(?:\\s+(\\w+))?/\ndef regexJoin = /(?i)\\b(?:LEFT\\s+)?JOIN\\b\\s+([\\w.]+)(?:\\s+(\\w+))?/\ndef columns = []\n\n// Find main table and its alias\ndef m = (transformedSql =~ regexFrom)\nif (m.find()) {\n    def tableName = m.group(1)\n    def alias = m.group(2)?.trim()\n    tableAliasMap[(alias ?: tableName)] = tableName\n}\n\n// Find join tables and aliases\ndef joins = (transformedSql =~ regexJoin)\nwhile (joins.find()) {\n    def tableName = joins.group(1)\n    def alias = joins.group(2)?.trim()\n    tableAliasMap[(alias ?: tableName)] = tableName\n}\n\n// Step 4: Extract columns from SELECT clause\ndef selectMatch = (transformedSql =~ /(?i)SELECT\\s+(.*?)\\s+FROM/)\ndef selectPart = selectMatch ? (selectMatch[0][1] ?: '') : ''\nselectPart = selectPart\n    .replaceFirst(/(?i)^\\s*DISTINCT\\s+ON\\s*\\([^)]*\\)\\s*/, '')\n    .replaceFirst(/(?i)^\\s*(ALL|DISTINCT)\\b\\s*/, '')\n// Handle column extraction more robustly\ndef columnItems = []\ndef depth = 0\ndef currentItem = new StringBuilder()\n\n// Split by comma but respect parentheses\nselectPart.each { ch ->\n    if (ch == '(') depth++\n    else if (ch == ')') depth--\n    \n    if (ch == ',' && depth == 0) {\n        columnItems << currentItem.toString().trim()\n        currentItem = new StringBuilder()\n    } else {\n        currentItem.append(ch)\n    }\n}\nif (currentItem.length() > 0) {\n    columnItems << currentItem.toString().trim()\n}\n\n// Process each column item\ncolumnItems.each { item ->\n    // Remove AS alias\n    def cleanItem = item.replaceAll(/(?i)\\s+AS\\s+\\w+/, '').trim()\n    \n    // Check for table.column pattern\n    def aliasColPattern = /\\b(\\w+)\\.(\\w+)\\b/\n    def aliasColMatch = cleanItem =~ aliasColPattern\n    \n    if (aliasColMatch.find()) {\n        columns << [alias: aliasColMatch.group(1), column: aliasColMatch.group(2)]\n    }\n    // Handle * or COUNT(*)\n    else if (cleanItem == '*' || cleanItem =~ /(?i)COUNT\\s*\\(\\s*\\*\\s*\\)/) {\n        if (tableAliasMap.size() == 1) {\n            columns << [alias: null, column: '*', table: tableAliasMap.values().first()]\n        } else {\n            columns << [alias: null, column: '*']\n        }\n    }\n    // Handle SUM, AVG, MAX, MIN, COUNT with DISTINCT and columns\n    else if (cleanItem =~ /(?i)(SUM|AVG|MAX|MIN|COUNT)\\s*\\(\\s*(DISTINCT\\s+)?([^)]+)\\s*\\)/) {\n        def funcMatch = cleanItem =~ /(?i)(SUM|AVG|MAX|MIN|COUNT)\\s*\\(\\s*(DISTINCT\\s+)?([^)]+)\\s*\\)/\n        if (funcMatch.find()) {\n            def innerExpr = funcMatch.group(3)?.trim()\n            def innerColMatch = innerExpr =~ /\\b(\\w+)\\.(\\w+)\\b/\n            if (innerColMatch.find()) {\n                columns << [alias: innerColMatch.group(1), column: innerColMatch.group(2)]\n            } else if (tableAliasMap.size() == 1 && innerExpr =~ /^\\w+$/) {\n                columns << [alias: null, column: innerExpr, table: tableAliasMap.values().first()]\n            }\n        }\n    }\n    // Handle simple column names (only if single table)\n    else if (tableAliasMap.size() == 1 && cleanItem =~ /^\\w+$/) {\n        columns << [alias: null, column: cleanItem, table: tableAliasMap.values().first()]\n    }\n}\n\n// Step 5: Build the output map\ndef resultMap = [:].withDefault{[]}\ncolumns.each { c ->\n    if (c.table) {\n        resultMap[c.table] << c.column\n    } else if (c.alias) {\n        def table = tableAliasMap[c.alias]\n        if (table) {\n            resultMap[table] << c.column\n        }\n    } else if (tableAliasMap.size() == 1) {\n        // No alias and single table: associate to that table\n        resultMap[tableAliasMap.values().first()] << c.column\n    }\n}\n\n// Remove duplicates\nresultMap.each { k, v -> resultMap[k] = v.unique() }\ndef tablesList = resultMap.collect { table, cols ->\n    [ table: table, columns: cols ]\n}\n\nreturn [\n    \"tables_list\": tablesList\n]\n",
				"parameters":{
					"sql_query":"{{ BWDmq.outputs.finalSQLquery }}"
				}
			},
			"skip":false,
			"subTitle":"extract info",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"additional":{
				"visibleOptionalFields":[
					"root.parameters.inputList.items",
					"root.parameters.metadataList.items"
				]
			},
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":451,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"n_WO2Rx",
			"index":27,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"result":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{},
								"additionalProperties":false
							},
							"title":"Result"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"input":{
					"type":"object",
					"properties":{
						"inputList":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{},
								"additionalProperties":false
							},
							"title":"Input List"
						},
						"metadataList":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{},
								"additionalProperties":false
							},
							"title":"Metadata List"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"compile_static":false,
				"code":"def res = []\nif(!binding.hasVariable('inputList')) inputList = []\ninputList.each { input ->\n    def tableName = input.table\n    def usedColumns = input.columns\n\n    usedColumns.each { col ->\n        def colMeta = metadataList.find { \n            it.table_name == tableName && it.column_name == col \n        }\n        if (colMeta) {\n            res << [\n                \"column_description\": colMeta.column_description,\n                \"column_label\": colMeta.column_label,\n                \"column_name\": colMeta.column_name,\n                \"knowledgeId\": colMeta.knowledgeId,\n                \"platform_name\": colMeta.platform_name,\n                \"tableDescription\": colMeta.tableDescription,\n                \"tableNameUI\": colMeta.tableNameUI,\n                \"table_name\": colMeta.table_name\n            ]\n        }\n    }\n}\n\nreturn [result: res]\n",
				"parameters":{
					"inputList":{
						"source":"{{ _GgFEO.outputs.result.tables_list }}",
						"ua:type":"mappedArray",
						"items":"{{ _GgFEO.outputs.result.tables_list[0] }}"
					},
					"metadataList":{
						"ua:type":"mappedArray",
						"source":"{{ _GK3Mq.outputs.result.metadata }}",
						"items":"{{ _GK3Mq.outputs.result.metadata[0] }}"
					}
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"additional":{
				"visibleOptionalFields":[
					"root.updateFields.items.fieldName",
					"root.updateFields.items.actionType"
				]
			},
			"context":{
				"appName":"storage_by_unifyapps",
				"resourceVersion":316,
				"resourceName":"storage_by_unifyapps_update_record_fields_by_id",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"_Wjjil",
			"index":28,
			"inputs":{
				"recordId":"{{ GpPp2.outputs.agentResponseMessageId }}",
				"writeThroughSessionVariables":true,
				"object_type":"service_hub_message",
				"skipPermissionCheck":false,
				"updateFields":[
					{
						"fieldName":"properties.additional.IsDataRAGExecuted",
						"actionType":"SET",
						"setValue":"True"
					},
					{
						"fieldName":"properties.additional.sqlQuery",
						"actionType":"SET",
						"setValue":"{{ BWDmq.outputs.finalSQLquery }}"
					},
					{
						"fieldName":"properties.additional.hasMoreData",
						"actionType":"SET",
						"setValue":"{{ nJq8F.outputs.hasMoreData }}"
					},
					{
						"fieldName":"properties.additional.usedMetadata",
						"actionType":"SET",
						"setValue":"{{ n_WO2Rx.outputs.result.result }}"
					}
				]
			},
			"skip":false,
			"subTitle":"Storage by UnifyApps",
			"title":"Update an existing record's fields",
			"type":"ACTION"
		},
		{
			"additional":{
				"visibleOptionalFields":[
					"root.parameters.metadata.items.table_name",
					"root.parameters.metadata.items.platform_name",
					"root.parameters.metadata.items.tableNameUI"
				]
			},
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":170,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"rp0ma",
			"index":29,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"chunks":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{},
								"additionalProperties":false
							},
							"title":"Chunks"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"input":{
					"type":"object",
					"properties":{
						"metadata":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{
									"table_name":{
										"type":"string",
										"title":"table_name"
									},
									"platform_name":{
										"type":"string",
										"title":"platform_name"
									},
									"tableNameUI":{
										"type":"string",
										"title":"Table Name UI"
									}
								},
								"additionalProperties":false,
								"required":[]
							},
							"title":"metadata"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"compile_static":false,
				"code":"def extractBeforeLastUnderscore = { String str ->\n    if(str == \"storage_by_unifyapps\"){\n      return str\n    }\n    int lastUnderscoreIndex = str.lastIndexOf('_')\n    if (lastUnderscoreIndex != -1) {\n        return str.substring(0, lastUnderscoreIndex)\n    } else {\n        return str // Return original string if no underscore is found\n    }\n}\n\ndef chunks = metadata\n    .unique { a, b -> a.table_name <=> b.table_name ?: a.platform_name <=> b.platform_name }\n    .collect { [ name: it.tableNameUI == null ? it.table_name: it.tableNameUI, appName: extractBeforeLastUnderscore(it.platform_name) ] }\n\nreturn [\"chunks\":chunks]",
				"parameters":{
					"metadata":{
						"ua:type":"mappedArray",
						"items":{
							"table_name":"{{ UqZEe.outputs.result.tableUsed[0].tableName }}",
							"platform_name":"{{ UqZEe.outputs.result.tableUsed[0].platformName }}",
							"tableNameUI":"{{ UqZEe.outputs.result.tableUsed[0].tableNameUI }}"
						},
						"source":"{{ UqZEe.outputs.result.tableUsed }}"
					}
				}
			},
			"skip":false,
			"subTitle":"Code by UnifyApps",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":180,
				"resourceName":"callables_call_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"JxHiB",
			"index":30,
			"inputs":{
				"automationId":"67ed33625e47b355f5f93529",
				"runtimeConnections":{},
				"synchronous":false,
				"version":"-1",
				"parameters":{
					"chunks":{
						"ua:type":"mappedArray",
						"source":"{{ rp0ma.outputs.result.chunks }}",
						"items":"{{ rp0ma.outputs.result.chunks[0] }}"
					},
					"aiAgentId":"{{ GpPp2.outputs.triggeredByAgentId }}",
					"caseId":"{{ GpPp2.outputs.caseId }}"
				}
			},
			"skip":false,
			"subTitle":"publish Reading block",
			"title":"Call automation",
			"type":"CALL_WORKFLOW"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":474,
				"resourceName":"callables_call_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"4pZYn",
			"index":31,
			"inputs":{
				"automationId":"67cc3ab09c3ab54c438320aa",
				"runtimeConnections":{},
				"synchronous":true,
				"version":"-1",
				"parameters":{
					"aiAgentId":"{{ GpPp2.outputs.triggeredByAgentId }}",
					"chunks":{
						"ua:type":"mappedArray",
						"source":"{{ rp0ma.outputs.result.chunks }}",
						"items":"{{ rp0ma.outputs.result.chunks[0] }}"
					}
				}
			},
			"skip":false,
			"subTitle":"Add Sources ",
			"title":"Call automation",
			"type":"CALL_WORKFLOW"
		},
		{
			"context":{
				"appName":"if_else",
				"resourceVersion":71,
				"resourceName":"if_else_condition",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"af1tm",
			"index":32,
			"inputs":{
				"filters":[
					{
						"property":"{{ o9ReY.outputs.columnNames[0] }}",
						"filter":{
							"operator":"EXISTS"
						}
					}
				],
				"operator":"AND"
			},
			"skip":false,
			"subTitle":"Condition",
			"title":"Condition",
			"type":"IF_ELSE"
		},
		{
			"context":{
				"appName":"utility_by_unifyapps",
				"resourceVersion":72,
				"resourceName":"utility_by_unifyapps_sequence_generator",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"af1tm@kFhpo-1@y",
			"id":"SgyMl",
			"index":33,
			"inputs":{
				"sequenceName":"{{ GpPp2.outputs.caseId }}_ChunkNumber"
			},
			"skip":false,
			"subTitle":"Utility by UnifyApps",
			"title":"Sequence Generator",
			"type":"ACTION"
		},
		{
			"additional":{
				"visibleOptionalFields":[
					"root.record.columnData.items",
					"root.record.rowData.items"
				]
			},
			"context":{
				"appName":"storage_by_unifyapps",
				"resourceVersion":72,
				"resourceName":"storage_by_unifyapps_create_record",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"af1tm@kFhpo-1@y",
			"id":"vHto4",
			"index":34,
			"inputs":{
				"writeThroughSessionVariables":false,
				"object_type":"citation_store",
				"record":{
					"hasMoreData":"{{ nJq8F.outputs.hasMoreData }}",
					"chunkNumber":"{{ SgyMl.outputs.result }}",
					"columnData":{
						"source":"{{ o9ReY.outputs.columnNames }}",
						"ua:type":"mappedArray",
						"items":"{{ o9ReY.outputs.columnNames[0] }}"
					},
					"rowData":{
						"source":"{{ o9ReY.outputs.rows }}",
						"ua:type":"mappedArray",
						"items":"{{ o9ReY.outputs.rows[0] }}"
					},
					"sqlQuery":"{{ BWDmq.outputs.finalSQLquery }}",
					"metadata":"{{ rp0ma.outputs.result.chunks[0] }}",
					"caseId":"{{ GpPp2.outputs.caseId }}",
					"sqlQueryPlatformName":"{{ _GK3Mq.outputs.result.platformName }}"
				}
			},
			"skip":false,
			"subTitle":"Storage by UnifyApps",
			"title":"Create record",
			"type":"ACTION"
		},
		{
			"additional":{
				"visibleOptionalFields":[
					"root.parameters.relevantContent.items",
					"root.parameters.columnData.items",
					"root.parameters.rowData.items"
				]
			},
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":17,
				"resourceName":"code_by_unifyapps_groovy",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"_yAylI",
			"index":35,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"finalOutput":{
							"type":"string",
							"title":"Final Output"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"input":{
					"type":"object",
					"properties":{
						"columnData":{
							"type":"array",
							"items":{
								"type":"string"
							},
							"title":"Column Data"
						},
						"rowData":{
							"type":"array",
							"items":{
								"type":"object",
								"properties":{},
								"additionalProperties":false
							},
							"title":"Row Data"
						},
						"chartId":{
							"type":"integer",
							"title":"Chart Id"
						},
						"hasMoreData":{
							"type":"boolean",
							"title":"Has More Data"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"compile_static":true,
				"code":"// // List<Map<String, Object>> chunkMetadataArray = []\n\n// if(!binding.hasVariable(\"columnData\") || !binding.hasVariable(\"rowData\")) return [\"finalOutput\" : \"\"]\n// def columns = (List<String>) binding.getProperty(\"columnData\")\n// def rows = (List<Map<String, Object>>) binding.getProperty(\"rowData\") \n\n// // def markdown = []\n// def markdown = ''\n// markdown += \"#### SQL Output <chartId=\\\"\" + binding.getProperty(\"chartId\") + \"\\\">\\n####\\n\"\n// markdown += \"<data>\\n\"\n// markdown += '| ' + columns.collect { it.toString() }.join(' | ') + ' |\\n'\n// markdown += '| ' + columns.collect { '---' }.join(' | ') + ' |\\n'\n// rows.each { row ->\n//     Map mapRow = row as Map\n//     markdown += '| ' + columns.collect { mapRow.containsKey(it) ? mapRow[it] : '' }.join(' | ') + ' |\\n'\n// }\n// markdown += \"</data>\\n\\n\"\n\n// // markdown += \"If this data seems relevant to what user has asked, user has explicitly asked for a table/chart/tabular representation/visual representation for this and the data is plottable and sending charts or tables is relevant for this query, then [IMPORTANT] make a tool call to \\\"GenerateChartWithBlocks\\\" with appropriate chartId and do not mention the table in markdown format in the final answer.\"\n// // if (binding.getProperty(\"hasMoreData\")) {\n// //     markdown += \"This sql output only contains a limited (truncated) number of rows and does not represent the full data. DO NOT make any conclusions or statements about the total count, minimum, maximum, or other aggregate statistics based solely on this sample as it is a truncated form of data. DO NOT pass any such conclusions based solely on the truncated data in the FINAL ANSWER.\"\n// // }\n// // if (binding.getProperty(\"hasMoreData\")) {\n// //         markdown += \"This sql output only contains a limited (truncated) number of rows and does not represent the full data. DO NOT make any conclusions or statements about the total count, minimum, maximum, or other aggregate statistics based solely on this sample as it is a truncated form of data. DO NOT pass any such conclusions based solely on the truncated data in the FINAL ANSWER. [STRICTLY] If the data is plottable or the user asks for visualization, make a tool call to \\\"GenerateChartWithBlocks\\\" with the given chartId and \\\"blockType\\\": \\\"Table\\\". If user asks explicitly about some other visual representation than table, then, politely deny by stating that chart can not be published due to \"\n// //     }\n// //     else{\n// //         markdown += \"If the user asks for a table, chart, or visualization, ONLY make a tool call to \\\"GenerateChartWithBlocks\\\" with the given chartId;  If this data seems relevant to what user has asked and the data is plottable and sending charts/tables is relevant for this query, then make a tool call to \\\"GenerateChartWithBlocks\\\" with appropriate chartId.\"\n// //     }\n\n// if (binding.getProperty(\"hasMoreData\")) {\n//     markdown += \"\"\"Note: This SQL output contains only a limited (truncated) number of rows and does not represent the complete dataset. - Do NOT draw aggregate or conclusions from this data. - [VERY IMPORTANT] If the user requests a chart, table, or data visualization, STRICTLY make a tool call to \\\"GenerateChartWithBlocks\\\" with the given chartId and \\\"blockType\": \"Table\\\". - If the user explicitly asks for a non-table visual representation, politely inform them that the chart type requested cannot be published. And just make a tool call to GenerateChartWithBlocks with TABLE as blockType.\"\"\"\n// } else {\n//     markdown += \"\"\" If the data is plottable or user requests a table, chart, or visualization, ONLY make a tool call to \\\"GenerateChartWithBlocks\\\" with the given chartId.\"\"\"\n// }\n\n// return [\n//     \"finalOutput\" : (markdown == null || markdown.trim().isEmpty()) ? null : markdown.trim()\n// ]\n\n// List<Map<String, Object>> chunkMetadataArray = []\n\nif(!binding.hasVariable(\"columnData\") || !binding.hasVariable(\"rowData\")) return [\"finalOutput\" : \"\"]\ndef columns = (List<String>) binding.getProperty(\"columnData\")\ndef rows = (List<Map<String, Object>>) binding.getProperty(\"rowData\") \nrows = rows.take(25)\n// def markdown = []\ndef markdown = ''\nmarkdown += \"#### SQL Output <chartId=\\\"\" + binding.getProperty(\"chartId\") + \"\\\">\\n####\\n\"\nmarkdown += \"<data>\\n\"\nmarkdown += '| ' + columns.collect { it.toString() }.join(' | ') + ' |\\n'\nmarkdown += '| ' + columns.collect { '---' }.join(' | ') + ' |\\n'\nrows.each { row ->\n    Map mapRow = row as Map\n    markdown += '| ' + columns.collect { mapRow.containsKey(it) ? mapRow[it] : '' }.join(' | ') + ' |\\n'\n}\nmarkdown += \"</data>\\n\\n\"\n\n// markdown += \"If this data seems relevant to what user has asked, user has explicitly asked for a table/chart/tabular representation/visual representation for this and the data is plottable and sending charts or tables is relevant for this query, then [IMPORTANT] make a tool call to \\\"GenerateChartWithBlocks\\\" with appropriate chartId and do not mention the table in markdown format in the final answer.\"\n// if (binding.getProperty(\"hasMoreData\")) {\n//     markdown += \"This sql output only contains a limited (truncated) number of rows and does not represent the full data. DO NOT make any conclusions or statements about the total count, minimum, maximum, or other aggregate statistics based solely on this sample as it is a truncated form of data. DO NOT pass any such conclusions based solely on the truncated data in the FINAL ANSWER.\"\n// }\n// if (binding.getProperty(\"hasMoreData\")) {\n//         markdown += \"This sql output only contains a limited (truncated) number of rows and does not represent the full data. DO NOT make any conclusions or statements about the total count, minimum, maximum, or other aggregate statistics based solely on this sample as it is a truncated form of data. DO NOT pass any such conclusions based solely on the truncated data in the FINAL ANSWER. [STRICTLY] If the data is plottable or the user asks for visualization, make a tool call to \\\"GenerateChartWithBlocks\\\" with the given chartId and \\\"blockType\\\": \\\"Table\\\". If user asks explicitly about some other visual representation than table, then, politely deny by stating that chart can not be published due to \"\n//     }\n//     else{\n//         markdown += \"If the user asks for a table, chart, or visualization, ONLY make a tool call to \\\"GenerateChartWithBlocks\\\" with the given chartId;  If this data seems relevant to what user has asked and the data is plottable and sending charts/tables is relevant for this query, then make a tool call to \\\"GenerateChartWithBlocks\\\" with appropriate chartId.\"\n//     }\n\n// if (binding.getProperty(\"hasMoreData\")) {\n//     markdown += \"\"\"Note: This SQL output contains only a limited (truncated) number of rows and does not represent the complete dataset. - Do NOT draw aggregate or conclusions from this data. - [VERY IMPORTANT] If the user requests a chart, table, or data visualization, STRICTLY make a tool call to \\\"GenerateChartWithBlocks\\\" with the given chartId and \\\"blockType\": \"Table\\\". - If the user explicitly asks for a non-table visual representation, politely inform them that the chart type requested cannot be published. And just make a tool call to GenerateChartWithBlocks with TABLE as blockType.\"\"\"\n// } else {\n//     markdown += \"\"\" If the data is plottable or user requests a table, chart, or visualization, ONLY make a tool call to \\\"GenerateChartWithBlocks\\\" with the given chartId.\"\"\"\n// }\n\n\nif (binding.getProperty(\"hasMoreData\")) {\n    markdown += \"\"\"Note: This SQL output contains only a limited (truncated) number of rows and does not represent the complete dataset. - Do NOT draw aggregate or conclusions from this data. [STRICTLY] As table is already published, dont try to republish table as it would result in duplicate information.\"\"\"\n    // \\\"blockType\": \"Table\\\". - If the user explicitly asks for a non-table visual representation, politely inform them that the chart type requested cannot be published. And just make a tool call to GenerateChartWithBlocks with TABLE as blockType.\"\"\"\n} else {\n    markdown += \"\"\" If the data is plottable or user requests a table, chart, or visualization, ONLY make a tool call to \\\"GenerateChartWithBlocks\\\" with the given chartId.\"\"\"\n}\n\n\nreturn [\n    \"finalOutput\" : (markdown == null || markdown.trim().isEmpty()) ? null : markdown.trim()\n]",
				"parameters":{
					"columnData":{
						"source":"{{ o9ReY.outputs.columnNames }}",
						"ua:type":"mappedArray",
						"items":"{{ o9ReY.outputs.columnNames[0] }}"
					},
					"rowData":{
						"source":"{{ o9ReY.outputs.rows }}",
						"ua:type":"mappedArray",
						"items":"{{ o9ReY.outputs.rows[0] }}"
					},
					"chartId":"{{ SgyMl.outputs.result }}",
					"hasMoreData":"{{ nJq8F.outputs.hasMoreData }}"
				}
			},
			"skip":false,
			"subTitle":"prepareOutput",
			"title":"Execute Groovy code",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"if_else",
				"resourceVersion":757,
				"resourceName":"if_else_condition",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"n_IbUJ4",
			"index":36,
			"inputs":{
				"filters":[
					{
						"property":"{{ nJq8F.outputs.hasMoreData }}",
						"filter":{
							"operator":"EQUAL",
							"value":"true"
						}
					}
				],
				"operator":"AND"
			},
			"skip":false,
			"subTitle":"Condition",
			"title":"Condition",
			"type":"IF_ELSE"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":812,
				"resourceName":"callables_call_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_IbUJ4@kFhpo-1@y",
			"id":"n_l4M3Q",
			"index":37,
			"inputs":{
				"automationId":"687a0640e048686b002fee4f",
				"runtimeConnections":{},
				"synchronous":true,
				"version":"-1",
				"parameters":{
					"chartId":"{{ SgyMl.outputs.result }}",
					"caseId":"{{ GpPp2.outputs.caseId }}",
					"metadata":{
						"source":"{{ Oqpz0.outputs.result.md }}",
						"ua:type":"mappedArray",
						"items":"{{ Oqpz0.outputs.result.md[0] }}"
					}
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Call automation",
			"type":"CALL_WORKFLOW"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":797,
				"resourceName":"callables_return_to_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"n_IbUJ4@kFhpo-1@y",
			"id":"n_YQP58",
			"index":38,
			"inputs":{
				"result":{
					"success":"{{ n_l4M3Q.outputs.success }}",
					"toolOutput":"{{ n_l4M3Q.outputs.tool_output }}; If user again explicitly demands a pictorial/visual representation, use this chartId, sql output can be used to see which blockType will be best for representation of data- {{ _yAylI.outputs.result.finalOutput }}. Strictly, avoid making tool call with blockType as Table as table has already been published for this data."
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to automation",
			"type":"STOP"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":17,
				"resourceName":"callables_return_to_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"kFhpo-1",
			"id":"_UuNZv",
			"index":39,
			"inputs":{
				"result":{
					"success":true,
					"toolOutput":"{{ _yAylI.outputs.result.finalOutput }}"
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to automation",
			"type":"STOP"
		}
	],
	"ownerUserId":38712,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":true,
	"version":86
}