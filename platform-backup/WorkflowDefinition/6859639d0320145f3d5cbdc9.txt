{
	"appsUsed":[
		
	],
	"createdTime":1750926265287,
	"deleted":false,
	"deploymentState":{
		"deployedAt":1758646555271,
		"deployedBy":0,
		"deployedDefinitionId":"68d2d11b9f85565fb8fa5ddf",
		"status":"DEPLOYED",
		"version":44,
		"workflowVersion":70
	},
	"edges":[
		{
			"fromNodeId":"oOSTj",
			"priority":0,
			"skip":false,
			"toNodeId":"V0YNm",
			"type":"next"
		},
		{
			"fromNodeId":"V0YNm",
			"priority":0,
			"skip":false,
			"toNodeId":"2ypMm",
			"type":"next"
		}
	],
	"grants":{
		"configs":[
			{
				"permissions":[
					"V"
				],
				"principalType":"GLOBAL"
			}
		]
	},
	"id":"6859639d0320145f3d5cbdc9",
	"lastModifiedBy":0,
	"lcName":"text to workflow v2 | update workflow adjacency list (debug)",
	"modifiedTime":1758655376879,
	"name":"Text to Workflow v2 | Update Workflow Adjacency List (debug)",
	"nodes":[
		{
			"context":{
				"appName":"callables",
				"resourceVersion":344,
				"resourceName":"callables_from_automation"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"ZZPbC-1",
			"id":"oOSTj",
			"index":0,
			"inputs":{
				"result":{
					"type":"object",
					"properties":{
						"output_workflow_json":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Output Workflow Json"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"setup":{
					"type":"object",
					"properties":{
						"workflow_json":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"Workflow Json"
						},
						"updates":{
							"type":"object",
							"properties":{
								"d":{
									"type":"string",
									"title":"d"
								},
								"deleteNodes":{
									"type":"array",
									"items":{
										"type":"string"
									},
									"title":"Delete Nodes"
								},
								"updatedInsertActions":{
									"type":"array",
									"items":{
										"type":"object",
										"properties":{},
										"additionalProperties":false
									},
									"title":"Updated Insert Actions"
								}
							},
							"additionalProperties":false,
							"title":"Updates",
							"required":[
								"d"
							]
						}
					},
					"additionalProperties":false,
					"required":[]
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Trigger via automation",
			"trigger":{
				"type":"CALLABLE"
			},
			"type":"START"
		},
		{
			"additional":{
				"visibleOptionalFields":[
					"root.parameters.updates.deleteNodes.items",
					"root.parameters.updates.updatedInsertActions.items"
				]
			},
			"context":{
				"appName":"code_by_unifyapps",
				"resourceVersion":323,
				"resourceName":"code_by_unifyapps_python",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"ZZPbC-1",
			"id":"V0YNm",
			"index":0,
			"inputs":{
				"output":{
					"type":"object",
					"properties":{
						"updatedWorkflow":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"updatedWorkflow"
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"input":{
					"type":"object",
					"properties":{
						"workflow_json":{
							"type":"object",
							"properties":{},
							"additionalProperties":false,
							"title":"workflow_json"
						},
						"updates":{
							"type":"object",
							"properties":{
								"deleteNodes":{
									"type":"array",
									"items":{
										"type":"string"
									},
									"title":"deleteNodes"
								},
								"d":{
									"type":"string",
									"title":"d"
								},
								"updatedInsertActions":{
									"type":"array",
									"items":{
										"type":"object",
										"properties":{},
										"additionalProperties":false
									},
									"title":"updatedInsertActions"
								}
							},
							"additionalProperties":false,
							"title":"updates",
							"required":[
								"d"
							]
						}
					},
					"additionalProperties":false,
					"required":[]
				},
				"code":"# TODO(LLD): Make this modular, extensible, easy to update, etc.\n\nfrom copy import deepcopy\nimport uuid\nfrom typing import Any, Dict, List\n\n\ndef update_workflow(workflow_json: Dict[str, Any],\n                    insert_list: List[Dict[str, Any]] | None = None,\n                    delete_list: List[str] | None = None) -> Dict[str, Any]:\n    \"\"\"\n    Merge inserts / deletes into `workflow_json` following all the rules.\n    \"\"\"\n\n    # ------------------------------------------------------------------ helpers\n    from copy import deepcopy\n    import uuid\n    from typing import Any, Dict, List\n    loopActions = [\n        \"loop_while\",\n        \"loop_for_each\",\n        \"pdf_by_unifyapps_for_each_split_file\",\n        \"pdf_by_unifyapps_for_each_page\",\n    ]\n\n    def _gen_random_id() -> str:\n        import uuid\n        \"\"\"first 5 chars of a random uuid – good enough for local ids\"\"\"\n        return \"n_\" + uuid.uuid4().hex[:5]\n\n    def _add_edge(node: Dict[str, Any], target: str, edge_type: str) -> None:\n        \"\"\"add an edge only if it does not already exist\"\"\"\n        if node[\"node_id\"] == target:\n            return\n        for e in node.setdefault(\"next\", []):\n            if e[\"node_id\"] == target and e[\"edge_type\"] == edge_type:\n                return\n        node[\"next\"].append({\"node_id\": target, \"edge_type\": edge_type})\n\n    def _category(action: str) -> str:\n        if action == \"if_else_condition\":\n            return \"if_else\"\n        if action == \"branch\":\n            return \"branch\"\n        if action in loopActions:\n            return \"loop\"\n        return \"normal\"\n\n    def _transfer_out_edge_type(action: str) -> str:\n        return {\n            \"if_else\":  \"next_after_condition_end\",\n            \"branch\":   \"next_after_branch_end\",\n            \"loop\":     \"next_after_loop_end\",\n            \"normal\":   \"next\",\n        }[_category(action)]\n\n    def _transform_edge_to_child(parent_edge: str, new_action: str) -> str:\n        \"\"\"\n        Rule-1: edge that is moved further down the chain.\n        For a newly-inserted special connector choose the ‘*_after_...’ edge,\n        otherwise default to simple 'next'.\n        \"\"\"\n        cat = _category(new_action)\n        if cat == \"if_else\":\n            return \"next_after_condition_end\"\n        if cat == \"branch\":\n            return \"next_after_branch_end\"\n        if cat == \"loop\":\n            return \"next_after_loop_end\"\n        return \"next\"\n\n\n    # TODO: This logic is not exhaustive (eg. when branch end contains another if_else or loop). Will fix this only if necessary.\n    def _find_last_nodes(id2node: dict, start_id: str) -> set:\n        \"\"\"\n        Return all leaf nodes reachable from `start_id` (following every edge).\n        Very small DFS – cycles are broken with a visited set.\n        \"\"\"\n        stack, visited, leaves = [start_id], set(), set()\n        while stack:\n            nid = stack.pop()\n            if nid in visited or nid not in id2node:\n                continue\n            visited.add(nid)\n            nxt = id2node[nid].get(\"next\", [])\n            if not nxt:\n                leaves.add(nid)\n            else:\n                for e in nxt:\n                    stack.append(e[\"node_id\"])\n        return leaves\n    \n    \n\n    def update_group_ids(id2node: Dict[str, Any], trigger_ids: List[str]) -> None:\n        \"\"\"Mutates *g* in-place, recomputing every node's groupId.\"\"\"\n\n        adjacency = {nid: node.get(\"next\", []) for nid, node in id2node.items()}\n        for tid in trigger_ids:\n            id2node[tid].setdefault(\"groupId\", f\"{tid}-1\")\n\n        visited: set[str] = set()\n        def _calculate_group_id(parent_id: str,\n                            parent_gid: str,\n                            parent_action: str,\n                            edge_type: str) -> str:\n        # ------------- Loop parent --------------------------------- #\n            if parent_action in loopActions:\n                if edge_type == \"next_inside_loop\":\n                    return f\"{parent_id}@{parent_gid}@l\"\n                return parent_gid\n\n            # ---------- If-Else parent ----------------------------------------- #\n            if parent_action == \"if_else_condition\":\n                if edge_type == \"next_if_condition_match\":\n                    return f\"{parent_id}@{parent_gid}@y\"\n                if edge_type == \"next_if_not_condition_match\":\n                    return f\"{parent_id}@{parent_gid}@n\"\n                return parent_gid\n\n            # ---------- Branch parent ----------------------------------------- #\n            if parent_action == \"branch\":\n                if edge_type == \"next_in_default_branch\":\n                    return f\"{parent_id}@{parent_gid}@default\"\n                if edge_type.startswith(\"next_in_branch_number\"):\n                    num = edge_type[len(\"next_in_branch_number\"):]\n                    return f\"{parent_id}@{parent_gid}@{num}\"\n                if edge_type.startswith(\"next_in_branch\") and edge_type[len(\"next_in_branch\"):].isdigit():\n                    num = edge_type[len(\"next_in_branch\"):]\n                    return f\"{parent_id}@{parent_gid}@{num}\"\n                return parent_gid\n\n            return parent_gid\n\n        def dfs(cur_id: str) -> None:\n            if cur_id in visited:\n                return\n            visited.add(cur_id)\n\n            parent      = id2node[cur_id]\n            parent_gid  = parent.get(\"groupId\", \"\")\n            parent_act  = parent.get(\"action_name\", \"\")\n\n            for edge in adjacency.get(cur_id, []):\n                # skip loopback so that we dfs over a tree \n                if 'loopback' in edge[\"edge_type\"]:\n                    continue\n\n                child_id  = edge[\"node_id\"]\n                if child_id not in id2node:\n                    continue\n\n                child_gid = _calculate_group_id(\n                    parent[\"node_id\"], parent_gid, parent_act, edge[\"edge_type\"]\n                )\n                id2node[child_id][\"groupId\"] = child_gid\n                dfs(child_id)\n\n        for tid in trigger_ids:\n            dfs(tid)\n\n    def _compact_branch_numbers(id2node: Dict[str, Any]) -> None:\n        \"\"\"\n        After nodes have been deleted, make sure each `branch` root:\n        • no longer references a fully-deleted branch arm\n        • has its remaining numeric arms renumbered contiguously (1 ... N)\n        • keeps the default arm and next_after_branch_end edge unchanged\n        • shows the correct labels in the UI\n        This helper mutates `id2node` in-place and relies on `_add_edge`\n        already being defined in the same file.\n        \"\"\"\n        # ---------- iterate over every branch root --------------------------------\n        for branch in [n for n in id2node.values()\n                    if n.get(\"action_name\") == \"branch\"]:\n\n            root_id        = branch[\"node_id\"]\n            existing_edges = branch.get(\"next\", [])\n\n            # -------- 1. separate numeric / default edges -------------------------\n            numeric_edges: list[Dict[str, Any]] = []\n            default_edge:  Dict[str, Any] | None = None\n\n            for e in existing_edges:\n                et = e[\"edge_type\"]\n\n                if et == \"next_in_default_branch\":\n                    default_edge = e\n                    continue\n\n                # accept “next_in_branch” or  “next_in_branch_number”\n                if et.startswith(\"next_in_branch_number\"):\n                    suffix = et[len(\"next_in_branch_number\"):]\n                elif et.startswith(\"next_in_branch\"):\n                    suffix = et[len(\"next_in_branch\"):]\n                else:\n                    continue\n\n                # keep only edges whose suffix is an int *and* whose wrapper node\n                # still exists *and* still has children (otherwise the whole arm\n                # was deleted).\n                if suffix.isdigit():\n                    wrapper_id = e[\"node_id\"]\n                    if wrapper_id in id2node and id2node[wrapper_id].get(\"next\"):\n                        e[\"_old_idx\"] = int(suffix)\n                        numeric_edges.append(e)\n\n            # skip if no branches left \n            if not numeric_edges:\n                continue\n\n            # sort by their old numeric index\n            numeric_edges.sort(key=lambda e: e[\"_old_idx\"])\n\n            # -------- 2. wipe outgoing edges / inputs; rebuild from scratch -------\n            branch[\"next\"]    = []\n            branch_inputs     = []\n            wrapper_id_map    : Dict[str, str] = {}  # map id old to new\n\n            for new_idx, e in enumerate(numeric_edges, start=1):\n                old_idx   = e[\"_old_idx\"]\n                old_wr_id = e[\"node_id\"]\n                new_wr_id = f\"{root_id}@{new_idx}\"\n\n                # ---- rename wrapper node if index changed -----------------------\n                if new_idx != old_idx:\n                    wrapper_node         = id2node.pop(old_wr_id)\n                    wrapper_node[\"node_id\"] = new_wr_id\n                    wrapper_node.setdefault(\"inputs\", {})[\"name\"] = f\"Branch {new_idx}\"\n                    # protect against collisions (very rare)\n                    id2node.pop(new_wr_id, None)\n                    id2node[new_wr_id]   = wrapper_node\n                    wrapper_id_map[old_wr_id] = new_wr_id\n                else:\n                    # keep the existing label but make sure it's correct\n                    id2node[old_wr_id].setdefault(\"inputs\", {})[\"name\"] = f\"Branch {new_idx}\"\n\n                # ---- recreate edge with new numbering ---------------------------\n                _add_edge(branch, new_wr_id, f\"next_in_branch{new_idx}\")\n\n                branch_inputs.append({\n                    \"id\": str(new_idx),\n                    \"inputs\": {\"name\": f\"Branch {new_idx}\"}\n                })\n\n            # keep default arm exactly as it was\n            if default_edge:\n                _add_edge(branch, default_edge[\"node_id\"], \"next_in_default_branch\")\n                branch_inputs.append({\"id\": \"default\"})\n\n            branch[\"inputs\"] = {\"branches\": branch_inputs}\n\n            # -------- 3. patch every other edge in the graph that still points\n            #            to an old wrapper id -------------------------------------\n            if wrapper_id_map:\n                for node in id2node.values():\n                    for ed in node.get(\"next\", []):\n                        ed_id = ed[\"node_id\"]\n                        if ed_id in wrapper_id_map:\n                            ed[\"node_id\"] = wrapper_id_map[ed_id]\n\n            # -------- 4. finally remove any parentless wrapper nodes ---------------\n            live_wrapper_ids = {ed[\"node_id\"] for ed in branch[\"next\"]}\n            for nid in list(id2node.keys()):\n                if nid.startswith(f\"{root_id}@\") and nid not in live_wrapper_ids and nid != root_id:\n                    del id2node[nid]\n \n\n    # ------------------------------------------------------------ Main Code\n    insert_list = insert_list or []\n    delete_list = delete_list or []\n\n    # deep-copy original so we do not mutate caller data\n    id2node = {n[\"node_id\"]: deepcopy(n) for n in workflow_json.get(\"nodes\", [])}\n    original_order = [n[\"node_id\"] for n in workflow_json.get(\"nodes\", [])]\n    insertion_order: list[str] = []\n\n    # ------------------------------------------------------------- Fix trigger node references\n    # 0. Handling of LLM errors: Fix trigger node reference if it exists (if LLM made a mistake)\n\n    # Find trigger\n    trigger_node_id = ''\n    for n_id, node in id2node.items():\n        if 'triggerNode' in node:\n            trigger_node_id = n_id\n            if node[\"node_name\"] == \"triggerToUpdate\":\n                node[\"node_name\"] = \"callables\"\n                node[\"action_name\"] = \"callables_from_automation\"\n\n    # Never delete the trigger node\n    for i, n_id in enumerate(delete_list):\n        if n_id == trigger_node_id:\n            delete_list.pop(i)\n            break\n\n    # Handle invalid insertion of trigger nodes\n    incorrect_trigger_idx = -1\n    for i, op in enumerate(insert_list):\n        if op.get(\"resource_type\") == \"TRIGGER\":\n            incorrect_trigger_idx = i\n            # break --> break was removed to handle the case when LLM mistakenly gives multiple triggers in \"insert\"\n    \n    insert_list = insert_list[max(incorrect_trigger_idx, 0):]\n    \n    # Now fix parent references to incorrect_trigger_id\n    if incorrect_trigger_idx >= 0:\n        for op in insert_list:\n            if op.get(\"parent_id\") == insert_list[incorrect_trigger_idx-incorrect_trigger_idx]['node_id']:\n                # Special case: LLM doesn't give trigger id\n                # To fix, I find the trigger node from previous workflow and then set that\n                op['parent_id'] = trigger_node_id\n                \n        insert_list.pop(incorrect_trigger_idx-incorrect_trigger_idx)\n\n    # ------------------------------------------------------------- INSERTION\n    # 1. first create deterministic mapping for all “#x” ids\n    pseudo2real = {item[\"node_id\"]: _gen_random_id() for item in insert_list}\n\n    # 2. process inserts sequentially\n    for ins in insert_list:\n        new_id = pseudo2real[ins[\"node_id\"]]\n        parent_id = pseudo2real.get(ins[\"parent_id\"], ins[\"parent_id\"])\n        if parent_id not in id2node:      \n            continue\n        parent = id2node[parent_id]\n        edge_type_parent_to_new = ins.get(\"edge_type\", \"next\")\n\n        # --- detach any existing child(ren) on the same edge\n        detached_children = []\n        new_parent_next = []\n        for e in parent.get(\"next\", []):\n            if e[\"edge_type\"] == edge_type_parent_to_new:\n                detached_children.append(e[\"node_id\"])\n            else:\n                new_parent_next.append(e)\n        parent[\"next\"] = new_parent_next\n\n        # --- create the new node object\n        new_node = {\n            \"node_id\": new_id,\n            \"node_name\": ins.get(\"node_name\") or ins.get(\"app_name\"),\n            \"action_name\": ins[\"action_name\"] if ins[\"action_name\"] != \"placeholder\" else \"\",\n            \"next\": []\n        }\n        id2node[new_id] = new_node\n        insertion_order.append(new_id)\n\n        # --- hook parent → new_node\n        _add_edge(parent, new_id, edge_type_parent_to_new)\n\n        # --- hook new_node → previous child(ren) (Rule-1)\n        for old_child in detached_children:\n            new_edge_type = _transform_edge_to_child(edge_type_parent_to_new,\n                                                     new_node[\"action_name\"])\n            _add_edge(new_node, old_child, new_edge_type)\n\n    # ---------------------------------------------------- BRANCH HANDLING\n    for branch in [n for n in id2node.values() if n.get(\"action_name\") == \"branch\"]:\n        root_id = branch[\"node_id\"]\n\n        # Force canonical metadata\n        branch[\"node_name\"] = \"branch\"\n        branch[\"context\"] = {\"appName\": \"branch\", \"type\": \"APPLICATION\"}\n\n        # split edges into arms (+ optional after-branch) ------------------\n        arms: list[tuple[str, str]] = []          # (edge_type, first_node_id)\n        after_branch_end: str | None = None\n        for e in branch.get(\"next\", []):\n            if e[\"edge_type\"] == \"next_after_branch_end\":\n                after_branch_end = e[\"node_id\"]\n            else:\n                arms.append((e[\"edge_type\"], e[\"node_id\"]))\n\n        # wipe current edges; we’ll rebuild them in canonical order\n        branch[\"next\"] = []\n        branch_inputs: list[Dict[str, Any]] = []\n        numbered_counter = 0\n\n        for etype, first_id in arms:\n            # ---------- identify branch ID --------------------------------\n            if etype in (\"next\"):\n                numbered_counter += 1\n                branch_id = str(numbered_counter)\n            elif etype.startswith(\"next_in_branch_number\"):\n                branch_id = etype[len(\"next_in_branch_number\"):]\n            elif etype.startswith(\"next_in_branch\"):\n                branch_id = etype[len(\"next_in_branch\"):]\n            elif etype == \"next_in_default_branch\":\n                branch_id = \"default\"\n            else:         \n                numbered_counter += 1\n                branch_id = str(numbered_counter)\n\n            # ---------- DEFAULT arm --------------------------------------\n            if branch_id == \"default\":\n                _add_edge(branch, first_id, \"next_in_default_branch\")\n                branch_inputs.append({\"id\": \"default\"})\n                continue\n\n            # ---------- NUMERIC arm --------------------------------------\n            bc_id = f\"{root_id}@{branch_id}\"\n            first_node = id2node[first_id]\n\n            if first_node.get(\"action_name\") == \"branch_condition\":\n                old_id = first_node[\"node_id\"]              \n                if old_id != bc_id:\n                    id2node[bc_id] = first_node\n                    del id2node[old_id]\n                    first_node[\"node_id\"] = bc_id\n                    for n in id2node.values():\n                        for ed in n.get(\"next\", []):\n                            if ed[\"node_id\"] == old_id:\n                                ed[\"node_id\"] = bc_id\n\n                bc_node = first_node\n                bc_node[\"node_name\"] = \"branch_condition\"\n                bc_node[\"action_name\"] = \"branch_condition\"\n                bc_node[\"context\"] = {\n                    \"appName\": \"branch_condition\",\n                    \"resourceName\": \"branch_condition\",\n                    \"resourceVersion\": 0,\n                    \"type\": \"APPLICATION\"\n                }\n                bc_node[\"inputs\"] = {\"name\": f\"Branch {branch_id}\"}\n            else:\n                # create a fresh branch-condition wrapper ------------------\n                bc_node = {\n                    \"node_id\": bc_id,\n                    \"node_name\": \"branch\",\n                    \"action_name\": \"branch\",\n                    \"context\": {\n                        \"appName\": \"branch\",\n                        \"resourceName\": \"branch\",\n                        \"resourceVersion\": 0,\n                        \"type\": \"APPLICATION\"\n                    },\n                    \"inputs\": {\"name\": f\"Branch {branch_id}\"},\n                    \"next\": []\n                }\n                id2node[bc_id] = bc_node\n                insertion_order.append(bc_id)\n                _add_edge(bc_node, first_id, \"next\")   # wrapper → first real node\n\n            # sanitise any legacy edges coming out of bc_node --------------\n            for ed in bc_node.get(\"next\", []):\n                if ed[\"edge_type\"].startswith(\"next_in_branch\"):\n                    ed[\"edge_type\"] = \"next\"\n\n            # hook root ➜ bc_node with canonical edge ----------------------\n            _add_edge(branch, bc_id, f\"next_in_branch{branch_id}\")\n\n            branch_inputs.append({\n                \"id\": branch_id,\n                \"inputs\": {\"name\": f\"Branch {branch_id}\"}\n            })\n\n        # always include a default entry in the inputs list\n        if not any(bi[\"id\"] == \"default\" for bi in branch_inputs):\n            branch_inputs.append({\"id\": \"default\"})\n        branch[\"inputs\"] = {\"branches\": branch_inputs}\n\n        # restore the single next_after_branch_end edge (if any)\n        if after_branch_end:\n            _add_edge(branch, after_branch_end, \"next_after_branch_end\")\n\n    # -------------------------------------------------- extra post-handling\n    # 1)  if-else : connect every branch-leaf  ──next──► outside-node\n    # 2)  loop    : connect every inside-loop leaf ──loopback_to_loop_start──► loop-node\n    for node in list(id2node.values()):\n\n        # ---------- IF / ELSE ------------------------------------------------\n        if node.get(\"action_name\") == \"if_else_condition\":\n            outside_edges = [\n                e for e in node.get(\"next\", [])\n                if e[\"edge_type\"] == \"next_after_condition_end\"\n            ]\n            if outside_edges:\n                outside_id = outside_edges[0][\"node_id\"]\n                for branch_edge in (\"next_if_condition_match\",\n                                    \"next_if_not_condition_match\"):\n                    for e in [e for e in node[\"next\"]\n                              if e[\"edge_type\"] == branch_edge]:\n                        leaves = _find_last_nodes(id2node, e[\"node_id\"])\n                        for leaf in leaves:\n                            _add_edge(id2node[leaf], outside_id, \"next\")\n\n        # ---------- LOOPS ----------------------------------------------------\n        if node.get(\"action_name\") in loopActions:\n            loop_id = node[\"node_id\"]\n            inside_edges = [\n                e for e in node.get(\"next\", [])\n                if e[\"edge_type\"] == \"next_inside_loop\"\n            ]\n            for e in inside_edges:\n                leaves = _find_last_nodes(id2node, e[\"node_id\"])\n                for leaf in leaves:\n                    _add_edge(id2node[leaf], loop_id, \"loopback_to_loop_start\")\n\n    # ---------------------------------------------------------------- DELETION\n    deletingBranch = False\n    for del_id in delete_list:\n        if id2node[del_id].get(\"action_name\") == \"branch_condition\":\n            deletingBranch = True           \n    for del_id in delete_list:\n        if del_id not in id2node:\n            continue\n        doomed = id2node[del_id]\n        \n        # 1. find every parent pointing to this node\n        parent_ids = [pid for pid, p in id2node.items()\n                      if any(e[\"node_id\"] == del_id for e in p.get(\"next\", []))]\n\n        # 2. which children should be re-attached?\n        child_edge_to_take = _transfer_out_edge_type(doomed[\"action_name\"])\n        children_to_keep = [e[\"node_id\"] for e in doomed.get(\"next\", [])\n                            if e[\"edge_type\"] == child_edge_to_take]\n\n        # 3. remove parent → doomed edge and rewire\n        for pid in parent_ids:\n            parent = id2node[pid]\n            removed_edge_types = [e[\"edge_type\"]\n                                  for e in parent[\"next\"]\n                                  if e[\"node_id\"] == del_id]\n            parent[\"next\"] = [e for e in parent[\"next\"]\n                              if e[\"node_id\"] != del_id]\n\n            # transfer\n            for transferred_child in children_to_keep:\n                for et in removed_edge_types:\n                    _add_edge(parent, transferred_child, et)\n\n        # finally eradicate doomed node\n        del id2node[del_id]\n\n    if deletingBranch:\n        _compact_branch_numbers(id2node)\n\n    # ---------------------------------------------------------------- Prune after first return/stop action\n    stopActions = [\"callables_return_to_automation\", \"callables_return_response_to_api\", \"stop\"]\n    for insertNode in insert_list:\n        if insertNode.get(\"action_name\") in stopActions:\n            realNodeId = pseudo2real[insertNode[\"node_id\"]]\n            if realNodeId in id2node:\n                id2node[realNodeId][\"next\"] = []\n\n    # ---------------------------------------------------------------- Add/Fix return action\n    trigger_action = id2node[trigger_node_id]['action_name']\n    traversal_edges = {\n        'next',\n        'next_after_loop_end',\n        'next_after_condition_end',\n        'next_if_condition_match',\n        'next_if_not_condition_match',\n        'next_after_branch_end',              # <-- branch-internal edges excluded\n    }\n\n    # dfs to find leaves; assuming if_else can never be leaves as per placeholder logic\n    leaves = set()\n    def _collect_leaves(nid: str):\n        outs = [\n            e for e in id2node[nid].get(\"next\", [])\n            if e[\"edge_type\"] in traversal_edges          \n        ]\n        if not outs:\n            leaves.add(nid)\n        for e in outs:\n            _collect_leaves(e[\"node_id\"])\n\n    _collect_leaves(trigger_node_id)\n\n    return_action, return_node_name = (\"stop\", \"stop\")\n    if trigger_action == 'callables_from_automation':\n        return_action, return_node_name = (\"callables_return_to_automation\", \"callables\")\n    elif trigger_action == 'callables_from_api':\n        return_action, return_node_name = (\"callables_return_response_to_api\", \"callables\")\n\n    for leaf_id in list(leaves):\n        leaf = id2node[leaf_id]\n        if leaf['action_name'] in stopActions:\n            leaf['action_name'] = return_action\n            leaf['node_name'] = return_node_name\n        else:\n            # append\n            new_node = {\n                'node_id': _gen_random_id(),\n                'action_name': return_action,\n                'node_name': return_node_name,\n                'next': []\n            }\n            id2node[new_node['node_id']] = new_node\n            # Case handling: Assuming if_else and for will have atleast 1 node (placeholder)\n            # regular node: append with \"next\"\n            # if_else: Append with \"next_after_condition_end\" and also handle branch leaves\n            # for: can be leaf --> Append with \"next_after_loop_end\"\n            \n            if id2node[leaf_id]['node_name'] == 'loop' or id2node[leaf_id]['node_name']=='pdf_by_unifyapps':\n                _add_edge(id2node[leaf_id], new_node['node_id'], \"next_after_loop_end\")\n            elif id2node[leaf_id]['node_name'] == 'if_else':  # This should never happen now\n                _add_edge(id2node[leaf_id], new_node['node_id'], \"next_after_condition_end\")\n                \n                # Find branch leaves and connect to new_node\n                for branch_edge in (\"next_if_condition_match\",\n                                    \"next_if_not_condition_match\"):\n                    for e in [e for e in id2node[leaf_id]['next']\n                              if e[\"edge_type\"] == branch_edge]:\n                        branch_leaves = _find_last_nodes(id2node, e[\"node_id\"])\n                        for _leaf in branch_leaves:\n                            _add_edge(id2node[_leaf], new_node['node_id'], \"next\")\n            elif id2node[leaf_id]['action_name'] == 'branch':\n                _add_edge(id2node[leaf_id], new_node['node_id'], \"next_after_branch_end\")\n            else:\n                _add_edge(id2node[leaf_id], new_node['node_id'], \"next\")\n\n    # ------------------------------------------- clean dangling edge targets\n    valid_ids = set(id2node)\n    for node in id2node.values():\n        node[\"next\"] = [\n            e for e in node.get(\"next\", [])\n            if e[\"node_id\"] in valid_ids\n        ]\n\n    # ------------------------------------------------------------------ PURGE\n    trigger_ids = [\n        n[\"node_id\"] for n in id2node.values()\n        if n.get(\"triggerNode\")\n    ]\n    reachable: set[str] = set()\n\n    def _dfs(nid: str):\n        if nid in reachable or nid not in id2node:\n            return\n        reachable.add(nid)\n        for e in id2node[nid].get(\"next\", []):\n            _dfs(e[\"node_id\"])\n\n    for tid in trigger_ids:\n        _dfs(tid)\n\n    update_group_ids(id2node, trigger_ids)\n    # produce ordered list: original order, then inserted nodes, keep only reachable\n    final_nodes = []\n    for nid in original_order + insertion_order:\n        if nid in reachable:\n            final_nodes.append(id2node[nid])\n    # any leftover reachable nodes not already appended\n    for nid in reachable:\n        if nid not in {n[\"node_id\"] for n in final_nodes}:\n            final_nodes.append(id2node[nid])\n\n    return {\"nodes\": final_nodes}\n\n\ninsert = updates.get(\"updatedInsertActions\", [])\ndelete = updates.get(\"deleteNodes\", [])\n\n# Update the workflow\nupdated_workflow = update_workflow(workflow_json, insert, delete)\n\n# Print the result\nresult = {\n    'updatedWorkflow': updated_workflow\n}",
				"isAsync":false,
				"parameters":{
					"updates":{
						"updatedInsertActions":{
							"ua:type":"mappedArray",
							"source":"{{ oOSTj.outputs.updates.updatedInsertActions }}",
							"items":"{{ oOSTj.outputs.updates.updatedInsertActions[0] }}"
						},
						"deleteNodes":{
							"ua:type":"mappedArray",
							"source":"{{ oOSTj.outputs.updates.deleteNodes }}",
							"items":"{{ oOSTj.outputs.updates.deleteNodes[0] }}"
						},
						"d":"{{ oOSTj.outputs.updates.d }}"
					},
					"workflow_json":"{{ oOSTj.outputs.workflow_json }}"
				}
			},
			"skip":false,
			"subTitle":"Update workflow adj list",
			"title":"Execute Python script",
			"type":"ACTION"
		},
		{
			"context":{
				"appName":"callables",
				"resourceVersion":350,
				"resourceName":"callables_return_to_automation",
				"type":"APPLICATION"
			},
			"debug":false,
			"dirty":false,
			"fallbackMode":"STOP",
			"groupId":"ZZPbC-1",
			"id":"2ypMm",
			"index":0,
			"inputs":{
				"result":{
					"output_workflow_json":"{{ V0YNm.outputs.result.updatedWorkflow }}"
				}
			},
			"skip":false,
			"subTitle":"Callable",
			"title":"Respond to automation",
			"type":"STOP"
		}
	],
	"ownerUserId":44096,
	"schemaReferences":[
		
	],
	"settings":{
		"enableNodeLevelLogging":true,
		"enableRunLogging":true,
		"enableVariableLogging":true,
		"route":{
			"default":false,
			"tierName":"global"
		}
	},
	"standard":true,
	"version":71
}